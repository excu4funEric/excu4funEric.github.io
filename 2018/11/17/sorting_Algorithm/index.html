<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>经典排序算法（持续更新） | excu4funEric</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
    <meta name="keywords" content="excu4fun,Eric's Blog" />
  
  <meta name="description" content="经典排序算法特征总结：   排序算法 时间复杂度平均情况 最坏情况 最好情况 空间复杂度 稳定性 复杂性     直接插入排序 O(n²) O(n²) O(n) O(1) 稳定 简单   希尔排序 O(nlog2n) O(nlog2n)  O(1) 不稳定 较复杂   冒泡排序 O(n²) O(n²) O(n) O(1) 稳定) 简单   快速排序 O(nlog2n) O(n²) O(nlog2n">
<meta name="keywords" content="算法">
<meta property="og:type" content="article">
<meta property="og:title" content="经典排序算法（持续更新）">
<meta property="og:url" content="http://excu4fun.com/2018/11/17/sorting_Algorithm/index.html">
<meta property="og:site_name" content="excu4funEric">
<meta property="og:description" content="经典排序算法特征总结：   排序算法 时间复杂度平均情况 最坏情况 最好情况 空间复杂度 稳定性 复杂性     直接插入排序 O(n²) O(n²) O(n) O(1) 稳定 简单   希尔排序 O(nlog2n) O(nlog2n)  O(1) 不稳定 较复杂   冒泡排序 O(n²) O(n²) O(n) O(1) 稳定) 简单   快速排序 O(nlog2n) O(n²) O(nlog2n">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://excu4fun.com/2018/11/17/sorting_Algorithm/HeapSort_1.png">
<meta property="og:image" content="http://excu4fun.com/2018/11/17/sorting_Algorithm/HeapSort_2.png">
<meta property="og:image" content="http://excu4fun.com/2018/11/17/sorting_Algorithm/ShellSort.png">
<meta property="og:image" content="http://excu4fun.com/2018/11/17/sorting_Algorithm/MergeSort.png">
<meta property="og:updated_time" content="2018-11-17T09:31:52.789Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="经典排序算法（持续更新）">
<meta name="twitter:description" content="经典排序算法特征总结：   排序算法 时间复杂度平均情况 最坏情况 最好情况 空间复杂度 稳定性 复杂性     直接插入排序 O(n²) O(n²) O(n) O(1) 稳定 简单   希尔排序 O(nlog2n) O(nlog2n)  O(1) 不稳定 较复杂   冒泡排序 O(n²) O(n²) O(n) O(1) 稳定) 简单   快速排序 O(nlog2n) O(n²) O(nlog2n">
<meta name="twitter:image" content="http://excu4fun.com/2018/11/17/sorting_Algorithm/HeapSort_1.png">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css">
  <script src="/js/pace.min.js"></script>
  

  
  

</head>

<body>
  <div id="container">
      <header id="header">
    <div id="banner"></div>
    <div id="header-outer">
        <div id="header-menu" class="header-menu-pos animated">
            <div class="header-menu-container">
                <a href="/" class="left">
                    <span class="site-title">Eric&#39;s Blog</span>
                </a>
                <nav id="header-menu-nav" class="right">
                    
                    <a  href="/">
                        <i class="fa fa-home"></i>
                        <span>Home</span>
                    </a>
                    
                    <a  href="/archives">
                        <i class="fa fa-archive"></i>
                        <span>Archives</span>
                    </a>
                    
                    <a  href="/about">
                        <i class="fa fa-user"></i>
                        <span>About</span>
                    </a>
                    
                </nav>
                <a class="mobile-header-menu-button">
                    <i class="fa fa-bars"></i>
                </a>
            </div>
        </div>
        <div id="header-row">
            <div id="logo">
                <a href="/">
                    <img src="/images/logo.png" alt="logo">
                </a>
            </div>
            <div class="header-info">
                <div id="header-title">
                    
                    <h2>
                        Eric&#39;s Blog
                    </h2>
                    
                </div>
                <div id="header-description">
                    
                    <h3>
                        记录工作生活中的点滴
                    </h3>
                    
                </div>
            </div>
            <nav class="header-nav">
                <div class="social">
                    
                        <a title="Eric" target="_blank" href="//excu4fun.com">
                            <i class="fa fa-home fa-2x"></i></a>
                    
                        <a title="Github" target="_blank" href="//github.com/excu4funEric">
                            <i class="fa fa-github fa-2x"></i></a>
                    
                        <a title="Weibo" target="_blank" href="//">
                            <i class="fa fa-weibo fa-2x"></i></a>
                    
                        <a title="Twitter" target="_blank" href="//twitter.com/excu4fun?">
                            <i class="fa fa-twitter fa-2x"></i></a>
                    
                </div>
            </nav>
        </div>
    </div>
</header>
      <div class="outer">
        <section id="main" class="body-wrap"><article id="post-sorting_Algorithm" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="post-title" itemprop="name">
      经典排序算法（持续更新）
    </h1>
    <div class="post-title-bar">
      <ul>
          
              <li>
                  <i class="fa fa-book"></i>
                  
                      <a href="/categories/排序算法/">排序算法</a>
                  
              </li>
          
        <li>
          <i class="fa fa-calendar"></i>  2018-11-17
        </li>
        <li>
          <i class="fa fa-eye"></i>
          <span id="busuanzi_value_page_pv"></span>
        </li>
      </ul>
    </div>
  

          
      </header>
    
    <div class="article-entry post-content" itemprop="articleBody">
      
            
            <h4 id="经典排序算法特征总结："><a href="#经典排序算法特征总结：" class="headerlink" title="经典排序算法特征总结："></a>经典排序算法特征总结：</h4><table>
<thead>
<tr>
<th>排序算法</th>
<th>时间复杂度平均情况</th>
<th>最坏情况</th>
<th>最好情况</th>
<th>空间复杂度</th>
<th>稳定性</th>
<th>复杂性</th>
</tr>
</thead>
<tbody>
<tr>
<td>直接插入排序</td>
<td>O(n²)</td>
<td>O(n²)</td>
<td>O(n)</td>
<td>O(1)</td>
<td>稳定</td>
<td>简单</td>
</tr>
<tr>
<td>希尔排序</td>
<td>O(nlog2n)</td>
<td>O(nlog2n)</td>
<td></td>
<td>O(1)</td>
<td>不稳定</td>
<td>较复杂</td>
</tr>
<tr>
<td>冒泡排序</td>
<td>O(n²)</td>
<td>O(n²)</td>
<td>O(n)</td>
<td>O(1)</td>
<td>稳定)</td>
<td>简单</td>
</tr>
<tr>
<td>快速排序</td>
<td>O(nlog2n)</td>
<td>O(n²)</td>
<td>O(nlog2n)</td>
<td>O(nlog2n)</td>
<td>不稳定</td>
<td>较复杂</td>
</tr>
<tr>
<td>直接选择排序</td>
<td>O(n²)</td>
<td>O(n²)</td>
<td>O(n²)</td>
<td>O(1)</td>
<td>不稳定</td>
<td>简单</td>
</tr>
<tr>
<td>堆排序</td>
<td>O(nlog2n)</td>
<td>O(nlog2n)</td>
<td>O(nlog2n)</td>
<td>O(1)</td>
<td>不稳定</td>
<td>较复杂</td>
</tr>
<tr>
<td>归并排序</td>
<td>O(nlog2n)</td>
<td>O(nlog2n)</td>
<td>O(nlog2n)</td>
<td>O(n)</td>
<td>稳定</td>
<td>较复杂</td>
</tr>
<tr>
<td>基数排序</td>
<td>O(d(n+r))</td>
<td>O(d(n+r))</td>
<td>O(d(n+r))</td>
<td>O(n+r)</td>
<td>稳定</td>
<td>较复杂</td>
</tr>
</tbody>
</table>
<h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p>&emsp;&emsp;冒泡排序是最简单的排序之一了，其大体思想就是通过与相邻元素的比较和交换来把小的数交换到最前面。这个过程类似于水泡向上升一样，因此而得名。冒泡排序的时间复杂度为O(n^2)。</p>
<p>java实现代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *@Description:&lt;p&gt;冒泡排序算法实现&lt;/p&gt;</span><br><span class="line"> *@author Eric Zhang</span><br><span class="line"> *@time 2018-11-17 下午13：34：19</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class BubbleSort &#123;</span><br><span class="line">	  public static void bubbleSort(int[] arr) &#123;</span><br><span class="line">	        if(arr == null || arr.length == 0)</span><br><span class="line">	            return ;</span><br><span class="line">	        for(int i=0; i&lt;arr.length-1; i++) &#123;</span><br><span class="line">	            for(int j=arr.length-1; j&gt;i; j--) &#123;</span><br><span class="line">	                if(arr[j] &lt; arr[j-1]) &#123;</span><br><span class="line">	                    swap(arr, j-1, j);</span><br><span class="line">	                &#125;</span><br><span class="line">	            &#125;</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	    </span><br><span class="line">	    </span><br><span class="line">	    public static void swap(int[] arr, int i, int j) &#123;</span><br><span class="line">	        int temp = arr[i];</span><br><span class="line">	        arr[i] = arr[j];</span><br><span class="line">	        arr[j] = temp;</span><br><span class="line">	    &#125;</span><br><span class="line">	    </span><br><span class="line">	    public static void main(String[] args) &#123;</span><br><span class="line">	    	int size = 10;  //数组大小</span><br><span class="line">	    	int [] arrayRefVar = new int[size]; //初始化</span><br><span class="line">	    	arrayRefVar[0] = 5;</span><br><span class="line">	    	arrayRefVar[1] = 4;</span><br><span class="line">	    	arrayRefVar[2] = 3;</span><br><span class="line">	    	arrayRefVar[3] = 13;</span><br><span class="line">	    	arrayRefVar[4] = 4;</span><br><span class="line">	    	arrayRefVar[5] = 34;</span><br><span class="line">	    	arrayRefVar[6] = 34;</span><br><span class="line">	    	arrayRefVar[7] = 45;</span><br><span class="line">	    	arrayRefVar[8] = 99;</span><br><span class="line">	    	arrayRefVar[9] = 1;</span><br><span class="line">	    	//排序前</span><br><span class="line">	    	for (int i = 0; i &lt; arrayRefVar.length; i++) &#123;</span><br><span class="line">	            System.out.println(arrayRefVar[i] + &quot; &quot;);</span><br><span class="line">	         &#125;</span><br><span class="line">	    	 System.out.println(&quot;排序后结果：&quot;);</span><br><span class="line">	    	bubbleSort(arrayRefVar);   </span><br><span class="line">	    	//排序后</span><br><span class="line">	    	for (int i = 0; i &lt; arrayRefVar.length; i++) &#123;</span><br><span class="line">	            System.out.println(arrayRefVar[i] + &quot; &quot;);</span><br><span class="line">	         &#125;</span><br><span class="line">	    	</span><br><span class="line">	    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">5 </span><br><span class="line">4 </span><br><span class="line">3 </span><br><span class="line">13 </span><br><span class="line">4 </span><br><span class="line">34 </span><br><span class="line">34 </span><br><span class="line">45 </span><br><span class="line">99 </span><br><span class="line">1 </span><br><span class="line">排序后结果：</span><br><span class="line">1 </span><br><span class="line">3 </span><br><span class="line">4 </span><br><span class="line">4 </span><br><span class="line">5 </span><br><span class="line">13 </span><br><span class="line">34 </span><br><span class="line">34 </span><br><span class="line">45 </span><br><span class="line">99</span><br></pre></td></tr></table></figure></p>
<p>C++实现代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">//整数或浮点数皆可使用</span><br><span class="line">void bubble_sort(T arr[], int len)</span><br><span class="line">&#123;</span><br><span class="line">    int i, j;  T temp;</span><br><span class="line">    for (i = 0; i &lt; len - 1; i++)</span><br><span class="line">        for (j = 0; j &lt; len - 1 - i; j++)</span><br><span class="line">        if (arr[j] &gt; arr[j + 1])</span><br><span class="line">        &#123;</span><br><span class="line">            temp = arr[j];</span><br><span class="line">            arr[j] = arr[j + 1];</span><br><span class="line">            arr[j + 1] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int arr[] = &#123; 61, 17, 29, 22, 34, 60, 72, 21, 50, 1, 62 &#125;;</span><br><span class="line">    int len = (int) sizeof(arr) / sizeof(*arr);</span><br><span class="line">    bubble_sort(arr, len);</span><br><span class="line">    for (int i = 0; i &lt; len; i++)</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; &apos; &apos;;</span><br><span class="line"> </span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    float arrf[] = &#123; 17.5, 19.1, 0.6, 1.9, 10.5, 12.4, 3.8, 19.7, 1.5, 25.4, 28.6, 4.4, 23.8, 5.4 &#125;;</span><br><span class="line">    len = (int) sizeof(arrf) / sizeof(*arrf);</span><br><span class="line">    bubble_sort(arrf, len);</span><br><span class="line">    for (int i = 0; i &lt; len; i++)</span><br><span class="line">        cout &lt;&lt; arrf[i] &lt;&lt; &apos; &apos;;</span><br><span class="line"> </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><p>&emsp;&emsp;选择排序的思想其实和冒泡排序有点类似，都是在一次排序后把最小的元素放到最前面。但是过程不同，冒泡排序是通过相邻的比较和交换。而选择排序是通过对整体的选择。选择排序的时间复杂度为O(n^2)<br>java实现代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *@Description:&lt;p&gt;选择排序算法实现&lt;/p&gt;</span><br><span class="line"> *@author Eric Zhang</span><br><span class="line"> *@time 2018-11-17 下午13：52: 11</span><br><span class="line"> */</span><br><span class="line">public class SelectSort &#123;</span><br><span class="line">    </span><br><span class="line">    public static void selectSort(int[] arr) &#123;</span><br><span class="line">        if(arr == null || arr.length == 0)</span><br><span class="line">            return ;</span><br><span class="line">        int minIndex = 0;</span><br><span class="line">        for(int i=0; i&lt;arr.length-1; i++) &#123; //只需要比较n-1次</span><br><span class="line">            minIndex = i;</span><br><span class="line">            for(int j=i+1; j&lt;arr.length; j++) &#123; //从i+1开始比较，因为minIndex默认为i了，i就没必要比了。</span><br><span class="line">                if(arr[j] &lt; arr[minIndex]) &#123;</span><br><span class="line">                    minIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            if(minIndex != i) &#123; //如果minIndex不为i，说明找到了更小的值，交换之。</span><br><span class="line">                swap(arr, i, minIndex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void swap(int[] arr, int i, int j) &#123;</span><br><span class="line">        int temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">    	int size = 10;  //数组大小</span><br><span class="line">    	int [] arrayRefVar = new int[size]; //初始化</span><br><span class="line">    	arrayRefVar[0] = 56;</span><br><span class="line">    	arrayRefVar[1] = 3;</span><br><span class="line">    	arrayRefVar[2] = 1;</span><br><span class="line">    	arrayRefVar[3] = 28;</span><br><span class="line">    	arrayRefVar[4] = 97;</span><br><span class="line">    	arrayRefVar[5] = 46;</span><br><span class="line">    	arrayRefVar[6] = 35;</span><br><span class="line">    	arrayRefVar[7] = 11;</span><br><span class="line">    	arrayRefVar[8] = 74;</span><br><span class="line">    	arrayRefVar[9] = 151;</span><br><span class="line">    	//排序前</span><br><span class="line">    	for (int i = 0; i &lt; arrayRefVar.length; i++) &#123;</span><br><span class="line">            System.out.println(arrayRefVar[i] + &quot; &quot;);</span><br><span class="line">         &#125;</span><br><span class="line">    	 System.out.println(&quot;排序后结果：&quot;);</span><br><span class="line">    	selectSort(arrayRefVar);   </span><br><span class="line">    	//排序后</span><br><span class="line">    	for (int i = 0; i &lt; arrayRefVar.length; i++) &#123;</span><br><span class="line">            System.out.println(arrayRefVar[i] + &quot; &quot;);</span><br><span class="line">         &#125;</span><br><span class="line">    	</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">56 </span><br><span class="line">3 </span><br><span class="line">1 </span><br><span class="line">28 </span><br><span class="line">97 </span><br><span class="line">46 </span><br><span class="line">35 </span><br><span class="line">11 </span><br><span class="line">74 </span><br><span class="line">151 </span><br><span class="line">排序后结果：</span><br><span class="line">1 </span><br><span class="line">3 </span><br><span class="line">11 </span><br><span class="line">28 </span><br><span class="line">35 </span><br><span class="line">46 </span><br><span class="line">56 </span><br><span class="line">74 </span><br><span class="line">97 </span><br><span class="line">151</span><br></pre></td></tr></table></figure></p>
<p>C++实现代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;time.h&gt;</span><br><span class="line">#include&lt;iomanip&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=10;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int a[N],i,j,temp,b;</span><br><span class="line">    srand(time(NULL));</span><br><span class="line">    for(i=0;i&lt;N;i++)</span><br><span class="line">        a[i]=rand()%100;</span><br><span class="line">    for(i=0;i&lt;N;i++)</span><br><span class="line">        cout&lt;&lt;setw(3)&lt;&lt;a[i];</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    for(i=0;i&lt;N-1;i++)&#123;</span><br><span class="line">        temp=i;</span><br><span class="line">        for(j=i+1;j&lt;N;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(a[temp]&gt;a[j])</span><br><span class="line">                temp=j;</span><br><span class="line">        &#125;</span><br><span class="line">        if(i!=temp)</span><br><span class="line">        &#123;</span><br><span class="line">            b=a[temp];</span><br><span class="line">            a[temp]=a[i];</span><br><span class="line">            a[i]=b;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(i=0;i&lt;N;i++)</span><br><span class="line">        cout&lt;&lt;setw(3)&lt;&lt;a[i];</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><p>&emsp;&emsp;插入排序不是通过交换位置而是通过比较找到合适的位置插入元素来达到排序的目的的。相信大家都有过打扑克牌的经历，特别是牌数较大的。在分牌时可能要整理自己的牌，牌多的时候怎么整理呢？就是拿到一张牌，找到一个合适的位置插入。插入排序的原理其实就是这样。简单插入排序的时间复杂度也是O(n²)。<br>java实现代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *@Description:&lt;p&gt;简单插入排序算法实现&lt;/p&gt;</span><br><span class="line"> *@author Eric Zhang</span><br><span class="line"> *@time 2018-11-17 下午14：06：43</span><br><span class="line"> */</span><br><span class="line">public class InsertSort &#123;</span><br><span class="line">    </span><br><span class="line">    public static void insertSort(int[] arr) &#123;</span><br><span class="line">        if(arr == null || arr.length == 0)</span><br><span class="line">            return ;</span><br><span class="line">        for(int i=1; i&lt;arr.length; i++) &#123; //假设第一个数位置时正确的；要往后移，必须要假设第一个。</span><br><span class="line">            int j = i;</span><br><span class="line">            int target = arr[i]; //待插入的</span><br><span class="line">            //后移</span><br><span class="line">            while(j &gt; 0 &amp;&amp; target &lt; arr[j-1]) &#123;</span><br><span class="line">                arr[j] = arr[j-1];</span><br><span class="line">                j --;</span><br><span class="line">            &#125;</span><br><span class="line">            //插入 </span><br><span class="line">            arr[j] = target;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">    	int size = 10;  //数组大小</span><br><span class="line">    	int [] arrayRefVar = new int[size]; //初始化</span><br><span class="line">    	arrayRefVar[0] = 97;</span><br><span class="line">    	arrayRefVar[1] = 26;</span><br><span class="line">    	arrayRefVar[2] = 55;</span><br><span class="line">    	arrayRefVar[3] = 63;</span><br><span class="line">    	arrayRefVar[4] = 1;</span><br><span class="line">    	arrayRefVar[5] = 42;</span><br><span class="line">    	arrayRefVar[6] = 7;</span><br><span class="line">    	arrayRefVar[7] = 98;</span><br><span class="line">    	arrayRefVar[8] = 66;</span><br><span class="line">    	arrayRefVar[9] = 21;</span><br><span class="line">    	//排序前</span><br><span class="line">    	for (int i = 0; i &lt; arrayRefVar.length; i++) &#123;</span><br><span class="line">            System.out.println(arrayRefVar[i] + &quot; &quot;);</span><br><span class="line">         &#125;</span><br><span class="line">    	 System.out.println(&quot;排序后结果：&quot;);</span><br><span class="line">    	 insertSort(arrayRefVar);   </span><br><span class="line">    	//排序后</span><br><span class="line">    	for (int i = 0; i &lt; arrayRefVar.length; i++) &#123;</span><br><span class="line">            System.out.println(arrayRefVar[i] + &quot; &quot;);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">97 </span><br><span class="line">26 </span><br><span class="line">55 </span><br><span class="line">63 </span><br><span class="line">1 </span><br><span class="line">42 </span><br><span class="line">7 </span><br><span class="line">98 </span><br><span class="line">66 </span><br><span class="line">21 </span><br><span class="line">排序后结果：</span><br><span class="line">1 </span><br><span class="line">7 </span><br><span class="line">21 </span><br><span class="line">26 </span><br><span class="line">42 </span><br><span class="line">55 </span><br><span class="line">63 </span><br><span class="line">66 </span><br><span class="line">97 </span><br><span class="line">98</span><br></pre></td></tr></table></figure></p>
<p>C++实现代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int a[]=&#123;98,76,109,34,67,190,80,12,14,89,1&#125;;</span><br><span class="line">    int k=sizeof(a)/sizeof(a[0]);</span><br><span class="line">    int j;</span><br><span class="line">    for(int i=1;i&lt;k;i++)&#123;//循环从第2个元素开始</span><br><span class="line">        if(a[i]&lt;a[i-1])&#123;</span><br><span class="line">            int temp=a[i];</span><br><span class="line">            for(j=i-1;j&gt;=0 &amp;&amp; a[j]&gt;temp;j--)</span><br><span class="line">            &#123;</span><br><span class="line">                a[j+1]=a[j];</span><br><span class="line">            &#125;</span><br><span class="line">            a[j+1]=temp;//此处就是a[j+1]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int f=0;f&lt;k;f++)&#123;</span><br><span class="line">        cout&lt;&lt;a[f]&lt;&lt;&quot;  &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>&emsp;&emsp;在实际应用当中快速排序是表现最好的排序算法。其思想是来自冒泡排序，冒泡排序是通过相邻元素的比较和交换把最小的冒泡到最顶端，而快速排序是比较和交换小数和大数，这样一来不仅把小数冒泡到上面同时也把大数沉到下面。快速排序是不稳定的，其时间平均时间复杂度是O(nlgn)。<br>java实现代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *@Description:&lt;p&gt;快速排序算法实现&lt;/p&gt;</span><br><span class="line"> *@author Eric Zhang</span><br><span class="line"> *@time 2018-11-17 下午14：37：03</span><br><span class="line"> */</span><br><span class="line">public class QuickSort &#123;</span><br><span class="line">    public static int partition(int[] arr, int left, int right) &#123;</span><br><span class="line">        int pivotKey = arr[left];</span><br><span class="line">        int pivotPointer = left;</span><br><span class="line">        </span><br><span class="line">        while(left &lt; right) &#123;</span><br><span class="line">            while(left &lt; right &amp;&amp; arr[right] &gt;= pivotKey)</span><br><span class="line">                right --;</span><br><span class="line">            while(left &lt; right &amp;&amp; arr[left] &lt;= pivotKey)</span><br><span class="line">                left ++;</span><br><span class="line">            swap(arr, left, right); //把大的交换到右边，把小的交换到左边。</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, pivotPointer, left); //最后把pivot交换到中间</span><br><span class="line">        return left;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void quickSort(int[] arr, int left, int right) &#123;</span><br><span class="line">        if(left &gt;= right)</span><br><span class="line">            return ;</span><br><span class="line">        int pivotPos = partition(arr, left, right);</span><br><span class="line">        quickSort(arr, left, pivotPos-1);</span><br><span class="line">        quickSort(arr, pivotPos+1, right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void sort(int[] arr) &#123;</span><br><span class="line">        if(arr == null || arr.length == 0)</span><br><span class="line">            return ;</span><br><span class="line">        quickSort(arr, 0, arr.length-1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void swap(int[] arr, int left, int right) &#123;</span><br><span class="line">        int temp = arr[left];</span><br><span class="line">        arr[left] = arr[right];</span><br><span class="line">        arr[right] = temp;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>优化版java实现代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *@Description:&lt;p&gt;快速排序算法实现&lt;/p&gt;</span><br><span class="line"> *@author Eric Zhang</span><br><span class="line"> *@time 2018-11-17 下午14：58：23</span><br><span class="line"> */</span><br><span class="line">public class QuickSort &#123;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 划分</span><br><span class="line">     * @param arr</span><br><span class="line">     * @param left</span><br><span class="line">     * @param right</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static int partition(int[] arr, int left, int right) &#123;</span><br><span class="line">        int pivotKey = arr[left];</span><br><span class="line">        </span><br><span class="line">        while(left &lt; right) &#123;</span><br><span class="line">            while(left &lt; right &amp;&amp; arr[right] &gt;= pivotKey)</span><br><span class="line">                right --;</span><br><span class="line">            arr[left] = arr[right]; //把小的移动到左边</span><br><span class="line">            while(left &lt; right &amp;&amp; arr[left] &lt;= pivotKey)</span><br><span class="line">                left ++;</span><br><span class="line">            arr[right] = arr[left]; //把大的移动到右边</span><br><span class="line">        &#125;</span><br><span class="line">        arr[left] = pivotKey; //最后把pivot赋值到中间</span><br><span class="line">        return left;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 递归划分子序列</span><br><span class="line">     * @param arr</span><br><span class="line">     * @param left</span><br><span class="line">     * @param right</span><br><span class="line">     */</span><br><span class="line">    public static void quickSort(int[] arr, int left, int right) &#123;</span><br><span class="line">        if(left &gt;= right)</span><br><span class="line">            return ;</span><br><span class="line">        int pivotPos = partition(arr, left, right);</span><br><span class="line">        quickSort(arr, left, pivotPos-1);</span><br><span class="line">        quickSort(arr, pivotPos+1, right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void sort(int[] arr) &#123;</span><br><span class="line">        if(arr == null || arr.length == 0)</span><br><span class="line">            return ;</span><br><span class="line">        quickSort(arr, 0, arr.length-1);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>C++实现代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void QucikSort(int a[], int left, int right)&#123;</span><br><span class="line">    if(left &gt;= right)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    int first = left;</span><br><span class="line">    int last = right;</span><br><span class="line">    int key = a[first];</span><br><span class="line">    while(first &lt; last)&#123;</span><br><span class="line">        while(first &lt; last &amp;&amp; a[last] &gt;= key)</span><br><span class="line">        &#123;</span><br><span class="line">            --last;</span><br><span class="line">        &#125;</span><br><span class="line">        a[first] = a[last];</span><br><span class="line">        while(first &lt; last &amp;&amp; a[first] &lt;= key)</span><br><span class="line">        &#123;</span><br><span class="line">            ++first;</span><br><span class="line">        &#125;</span><br><span class="line">        a[last] = a[first];    </span><br><span class="line">    &#125;</span><br><span class="line">    a[first] = key;</span><br><span class="line">    QuickSort(a, left, first-1);</span><br><span class="line">    QuickSort(a, first+1, right);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int a[] = &#123;11, 7, 99, 44, 121, 54, 66, 77, 22, 31&#125;;</span><br><span class="line">    QuickSort(a, 0, sizeof(a) / sizeof(a[0]) - 1);</span><br><span class="line">    for(int i = 0; i &lt; sizeof(a) / sizeof(a[0]); i++)&#123;</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>总结快速排序的思想：冒泡+二分+递归分治</strong></p>
<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p>&emsp;&emsp;堆排序是借助堆来实现的选择排序，思想同简单的选择排序，以下以大顶堆为例。注意：如果想升序排序就使用大顶堆，反之使用小顶堆。原因是堆顶元素需要交换到序列尾部。<br>&emsp;&emsp;首先，实现堆排序需要解决两个问题：<br>&emsp;&emsp;1. 如何由一个无序序列键成一个堆？<br>&emsp;&emsp;2. 如何在输出堆顶元素之后，调整剩余元素成为一个新的堆？<br>&emsp;&emsp;第一个问题，可以直接使用线性数组来表示一个堆，由初始的无序序列建成一个堆就需要自底向上从第一个非叶元素开始挨个调整成一个堆。<br>&emsp;&emsp;第二个问题，怎么调整成堆？首先是将堆顶元素和最后一个元素交换。然后比较当前堆顶元素的左右孩子节点，因为除了当前的堆顶元素，左右孩子堆均满足条件，这时需要选择当前堆顶元素与左右孩子节点的较大者（大顶堆）交换，直至叶子节点。我们称这个自堆顶自叶子的调整成为筛选。<br>&emsp;&emsp;从一个无序序列建堆的过程就是一个反复筛选的过程。若将此序列看成是一个完全二叉树，则最后一个非终端节点是n/2取底个元素，由此筛选即可。举个栗子：<br>49,38,65,97,76,13,27,49序列的堆排序建初始堆和调整的过程如下：<br><img src="/2018/11/17/sorting_Algorithm/HeapSort_1.png"><br><img src="/2018/11/17/sorting_Algorithm/HeapSort_2.png"></p>
<p>java实现代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *@Description:&lt;p&gt;堆排序算法实现&lt;/p&gt;</span><br><span class="line"> *@author Eric Zhang</span><br><span class="line"> *@time 2018-11-17 下午15：47：09</span><br><span class="line"> */</span><br><span class="line">public class HeapSort &#123;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 堆筛选，除了start之外，start~end均满足大顶堆的定义。</span><br><span class="line">     * 调整之后start~end称为一个大顶堆。</span><br><span class="line">     * @param arr 待调整数组</span><br><span class="line">     * @param start 起始指针</span><br><span class="line">     * @param end 结束指针</span><br><span class="line">     */</span><br><span class="line">    public static void heapAdjust(int[] arr, int start, int end) &#123;</span><br><span class="line">        int temp = arr[start];</span><br><span class="line">        for(int i=2*start+1; i&lt;=end; i*=2) &#123;</span><br><span class="line">            //左右孩子的节点分别为2*i+1,2*i+2</span><br><span class="line">            </span><br><span class="line">            //选择出左右孩子较小的下标</span><br><span class="line">            if(i &lt; end &amp;&amp; arr[i] &lt; arr[i+1]) &#123;</span><br><span class="line">                i ++; </span><br><span class="line">            &#125;</span><br><span class="line">            if(temp &gt;= arr[i]) &#123;</span><br><span class="line">                break; //已经为大顶堆，=保持稳定性。</span><br><span class="line">            &#125;</span><br><span class="line">            arr[start] = arr[i]; //将子节点上移</span><br><span class="line">            start = i; //下一轮筛选</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        arr[start] = temp; //插入正确的位置</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    public static void heapSort(int[] arr) &#123;</span><br><span class="line">        if(arr == null || arr.length == 0)</span><br><span class="line">            return ;</span><br><span class="line">        </span><br><span class="line">        //建立大顶堆</span><br><span class="line">        for(int i=arr.length/2; i&gt;=0; i--) &#123;</span><br><span class="line">            heapAdjust(arr, i, arr.length-1);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        for(int i=arr.length-1; i&gt;=0; i--) &#123;</span><br><span class="line">            swap(arr, 0, i);</span><br><span class="line">            heapAdjust(arr, 0, i-1);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void swap(int[] arr, int i, int j) &#123;</span><br><span class="line">        int temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>C++实现代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">void max_heapify(int arr[], int start, int end) &#123;</span><br><span class="line">    //建立父节点指标和子节点指标</span><br><span class="line">    int dad = start;</span><br><span class="line">    int son = dad * 2 + 1;</span><br><span class="line">    while (son &lt;= end) &#123; //若子节点指标在范围内才做比较</span><br><span class="line">        if (son + 1 &lt;= end &amp;&amp; arr[son] &lt; arr[son + 1]) //先比较两个子节点大小，选择最大的</span><br><span class="line">            son++;</span><br><span class="line">        if (arr[dad] &gt; arr[son]) //如果父节点大於子节点代表调整完毕，直接跳出函数</span><br><span class="line">            return;</span><br><span class="line">        else &#123; //否则交换父子内容再继续子节点和孙节点比较</span><br><span class="line">            swap(arr[dad], arr[son]);</span><br><span class="line">            dad = son;</span><br><span class="line">            son = dad * 2 + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void heap_sort(int arr[], int len) &#123;</span><br><span class="line">    //初始化，i从最後一个父节点开始调整</span><br><span class="line">    for (int i = len / 2 - 1; i &gt;= 0; i--)</span><br><span class="line">        max_heapify(arr, i, len - 1);</span><br><span class="line">    //先将第一个元素和已经排好的元素前一位做交换，再从新调整(刚调整的元素之前的元素)，直到排序完毕</span><br><span class="line">    for (int i = len - 1; i &gt; 0; i--) &#123;</span><br><span class="line">        swap(arr[0], arr[i]);</span><br><span class="line">        max_heapify(arr, 0, i - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main() &#123;</span><br><span class="line">    int arr[] = &#123; 3, 5, 3, 0, 8, 6, 1, 5, 8, 6, 2, 4, 9, 4, 7, 0, 1, 8, 9, 7, 3, 1, 2, 5, 9, 7, 4, 0, 2, 6 &#125;;</span><br><span class="line">    int len = (int) sizeof(arr) / sizeof(*arr);</span><br><span class="line">    heap_sort(arr, len);</span><br><span class="line">    for (int i = 0; i &lt; len; i++)</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; &apos; &apos;;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><p>&emsp;&emsp;希尔排序是插入排序的一种高效率的实现，也叫缩小增量排序。简单的插入排序中，如果待排序列是正序时，时间复杂度是O(n)，如果序列是基本有序的，使用直接插入排序效率就非常高。希尔排序就利用了这个特点。基本思想是：先将整个待排记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录基本有序时再对全体记录进行一次直接插入排序。<br><img src="/2018/11/17/sorting_Algorithm/ShellSort.png"><br>&emsp;&emsp;从上述排序过程可见，希尔排序的特点是，子序列的构成不是简单的逐段分割，而是将某个相隔某个增量的记录组成一个子序列。如上面的例子，第一堂排序时的增量为5，第二趟排序的增量为3。由于前两趟的插入排序中记录的关键字是和同一子序列中的前一个记录的关键字进行比较，因此关键字较小的记录就不是一步一步地向前挪动，而是跳跃式地往前移，从而使得进行最后一趟排序时，整个序列已经做到基本有序，只要作记录的少量比较和移动即可。因此希尔排序的效率要比直接插入排序高。<br>&emsp;&emsp;希尔排序的分析是复杂的，时间复杂度是所取增量的函数，这涉及一些数学上的难题。但是在大量实验的基础上推出当n在某个范围内时，时间复杂度可以达到O(n^1.3)。</p>
<p>java实现代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *@Description:&lt;p&gt;希尔排序算法实现&lt;/p&gt;</span><br><span class="line"> *@author Eric Zhang</span><br><span class="line"> *@time 2018-11-17 下午16：31：41</span><br><span class="line"> */</span><br><span class="line">public class ShellSort &#123;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 希尔排序的一趟插入</span><br><span class="line">     * @param arr 待排数组</span><br><span class="line">     * @param d 增量</span><br><span class="line">     */</span><br><span class="line">    public static void shellInsert(int[] arr, int d) &#123;</span><br><span class="line">        for(int i=d; i&lt;arr.length; i++) &#123;</span><br><span class="line">            int j = i - d;</span><br><span class="line">            int temp = arr[i];    //记录要插入的数据  </span><br><span class="line">            while (j&gt;=0 &amp;&amp; arr[j]&gt;temp) &#123;  //从后向前，找到比其小的数的位置   </span><br><span class="line">                arr[j+d] = arr[j];    //向后挪动  </span><br><span class="line">                j -= d;  </span><br><span class="line">            &#125;  </span><br><span class="line">      </span><br><span class="line">            if (j != i - d)    //存在比其小的数 </span><br><span class="line">                arr[j+d] = temp;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void shellSort(int[] arr) &#123;</span><br><span class="line">        if(arr == null || arr.length == 0)</span><br><span class="line">            return ;</span><br><span class="line">        int d = arr.length / 2;</span><br><span class="line">        while(d &gt;= 1) &#123;</span><br><span class="line">            shellInsert(arr, d);</span><br><span class="line">            d /= 2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C++实现代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void swapInt(int * a,int*b)&#123;</span><br><span class="line">	int c=*a;</span><br><span class="line">	*a=*b;</span><br><span class="line">	*b=c;</span><br><span class="line">&#125;</span><br><span class="line">void shell(int*data,unsigned int len)&#123;</span><br><span class="line">	if(len&lt;=1||data==NULL)</span><br><span class="line">	return;</span><br><span class="line">	for(int div=len/2;div&gt;=1;div=div/2)&#123;//定增量div，并不断减小</span><br><span class="line">		for(int i=0;i&lt;div;++i)&#123;//分组成div组</span><br><span class="line">			for(int j=i;j&lt;len-div;j+=div)//对每组进行插入排序</span><br><span class="line">				for(int k=j;k&lt;len;k+=div)</span><br><span class="line">					if(data[j]&gt;data[k])</span><br><span class="line">					swapInt(data+j,data+k);//交换两个数的值</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p>&emsp;&emsp;归并排序是另一种不同的排序方法，因为归并排序使用了递归分治的思想，所以理解起来比较容易。其基本思想是，先递归划分子问题，然后合并结果。把待排序列看成由两个有序的子序列，然后合并两个子序列，然后把子序列看成由两个有序序列。。。。。倒着来看，其实就是先两两合并，然后四四合并。。。最终形成有序序列。空间复杂度为O(n)，时间复杂度为O(nlogn)。<br><img src="/2018/11/17/sorting_Algorithm/MergeSort.png"></p>
<p>java实现代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *@Description:&lt;p&gt;归并排序算法实现&lt;/p&gt;</span><br><span class="line"> *@author Eric Zhang</span><br><span class="line"> *@time 2018-11-17 下午16：55：52</span><br><span class="line"> */</span><br><span class="line">public class MergeSort &#123;</span><br><span class="line">    </span><br><span class="line">    public static void mergeSort(int[] arr) &#123;</span><br><span class="line">        mSort(arr, 0, arr.length-1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 递归分治</span><br><span class="line">     * @param arr 待排数组</span><br><span class="line">     * @param left 左指针</span><br><span class="line">     * @param right 右指针</span><br><span class="line">     */</span><br><span class="line">    public static void mSort(int[] arr, int left, int right) &#123;</span><br><span class="line">        if(left &gt;= right)</span><br><span class="line">            return ;</span><br><span class="line">        int mid = (left + right) / 2;</span><br><span class="line">        </span><br><span class="line">        mSort(arr, left, mid); //递归排序左边</span><br><span class="line">        mSort(arr, mid+1, right); //递归排序右边</span><br><span class="line">        merge(arr, left, mid, right); //合并</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 合并两个有序数组</span><br><span class="line">     * @param arr 待合并数组</span><br><span class="line">     * @param left 左指针</span><br><span class="line">     * @param mid 中间指针</span><br><span class="line">     * @param right 右指针</span><br><span class="line">     */</span><br><span class="line">    public static void merge(int[] arr, int left, int mid, int right) &#123;</span><br><span class="line">        //[left, mid] [mid+1, right]</span><br><span class="line">        int[] temp = new int[right - left + 1]; //中间数组</span><br><span class="line">        </span><br><span class="line">        int i = left;</span><br><span class="line">        int j = mid + 1;</span><br><span class="line">        int k = 0;</span><br><span class="line">        while(i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">            if(arr[i] &lt;= arr[j]) &#123;</span><br><span class="line">                temp[k++] = arr[i++];</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                temp[k++] = arr[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        while(i &lt;= mid) &#123;</span><br><span class="line">            temp[k++] = arr[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        while(j &lt;= right) &#123;</span><br><span class="line">            temp[k++] = arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        for(int p=0; p&lt;temp.length; p++) &#123;</span><br><span class="line">            arr[left + p] = temp[p];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>C++实现代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line">//非递归实现：</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;ctime&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">/**将a开头的长为length的数组和b开头长为right的数组合并n为数组长度，用于最后一组*/</span><br><span class="line">void　Merge(int*　data,int　a,int　b,int　length,int　n)&#123;</span><br><span class="line">　int　right;</span><br><span class="line">　if(b+length-1 &gt;= n-1)　right = n-b;</span><br><span class="line">　else　right = length;</span><br><span class="line">　int*　temp = new　int[length+right];</span><br><span class="line">　int　i=0, j=0;</span><br><span class="line">　while(i&lt;=length-1 &amp;&amp; j&lt;=right-1)&#123;</span><br><span class="line">    　if(data[a+i] &lt;= data[b+j])&#123;</span><br><span class="line">    　    temp[i+j] = data[a+i];i++;</span><br><span class="line">      &#125;</span><br><span class="line">    　else&#123;</span><br><span class="line">        temp[i+j] = data[b+j];</span><br><span class="line">        j++;</span><br><span class="line">      &#125;</span><br><span class="line">　&#125;</span><br><span class="line">　if(j == right)&#123;//a中还有元素，且全都比b中的大,a[i]还未使用</span><br><span class="line">　  memcpy(temp + i + j, data + a + i, (length - i) * sizeof(int));</span><br><span class="line">　&#125;</span><br><span class="line">  else if(i == length)&#123;</span><br><span class="line">      memcpy(temp + i + j, data + b + j, (right - j)*sizeof(int));</span><br><span class="line">  &#125;</span><br><span class="line">　memcpy(data+a, temp, (right + length) * sizeof(int));</span><br><span class="line">　delete [] temp;</span><br><span class="line">&#125;</span><br><span class="line">void　MergeSort(int*　data, int　n)&#123;</span><br><span class="line">　int　step = 1;</span><br><span class="line">　while(step &lt; n)&#123;</span><br><span class="line">    　for(int　i=0; i&lt;=n-step-1; i+=2*step)</span><br><span class="line">    　    Merge(data, i, i+step, step, n);</span><br><span class="line">    //将i和i+step这两个有序序列进行合并</span><br><span class="line">    //序列长度为step</span><br><span class="line">    //当i以后的长度小于或者等于step时，退出</span><br><span class="line">    　step*=2;//在按某一步长归并序列之后，步长加倍</span><br><span class="line">　&#125;</span><br><span class="line">&#125;</span><br><span class="line">int　main()&#123;</span><br><span class="line">　int　n;</span><br><span class="line">　cin&gt;&gt;n;</span><br><span class="line">　int*　data = new　int[n];</span><br><span class="line">　if(!data)　exit(1);</span><br><span class="line">　int　k = n;</span><br><span class="line">　while(k--)&#123;</span><br><span class="line">　    cin&gt;&gt;data[n-k-1];</span><br><span class="line">　&#125;</span><br><span class="line">　clock_t　s = clock();</span><br><span class="line">　MergeSort(data, n);</span><br><span class="line">　clock_t　e = clock();</span><br><span class="line">　k=n;</span><br><span class="line">　while(k--)&#123;</span><br><span class="line">　    cout&lt;&lt;data[n-k-1]&lt;&lt;&apos; &apos;;</span><br><span class="line">　&#125;</span><br><span class="line">　cout&lt;&lt;endl;</span><br><span class="line">　cout&lt;&lt;&quot;the algorithm used&quot;&lt;&lt;e-s&lt;&lt;&quot;miliseconds.&quot;&lt;&lt;endl;</span><br><span class="line">　delete　data;</span><br><span class="line">　return　0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//递归实现：</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void merge(int *data, int start, int mid, int end, int *result)</span><br><span class="line">&#123;</span><br><span class="line">    int i, j, k;</span><br><span class="line">    i = start;</span><br><span class="line">    j = mid + 1;                        //避免重复比较data[mid]</span><br><span class="line">    k = 0;</span><br><span class="line">    while (i &lt;= mid &amp;&amp; j &lt;= end)        //数组data[start,mid]与数组(mid,end]均没有全部归入数组result中去</span><br><span class="line">    &#123;</span><br><span class="line">        if (data[i] &lt;= data[j])         //如果data[i]小于等于data[j]</span><br><span class="line">            result[k++] = data[i++];    //则将data[i]的值赋给result[k]，之后i,k各加一，表示后移一位</span><br><span class="line">        else</span><br><span class="line">            result[k++] = data[j++];    //否则，将data[j]的值赋给result[k]，j,k各加一</span><br><span class="line">    &#125;</span><br><span class="line">    while (i &lt;= mid)                    //表示数组data(mid,end]已经全部归入result数组中去了，而数组data[start,mid]还有剩余</span><br><span class="line">        result[k++] = data[i++];        //将数组data[start,mid]剩下的值，逐一归入数组result</span><br><span class="line">    while (j &lt;= end)                    //表示数组data[start,mid]已经全部归入到result数组中去了，而数组(mid,high]还有剩余</span><br><span class="line">        result[k++] = data[j++];        //将数组a[mid,high]剩下的值，逐一归入数组result</span><br><span class="line"> </span><br><span class="line">    for (i = 0; i &lt; k; i++)             //将归并后的数组的值逐一赋给数组data[start,end]</span><br><span class="line">        data[start + i] = result[i];    //注意，应从data[start+i]开始赋值</span><br><span class="line">&#125;</span><br><span class="line">void merge_sort(int *data, int start, int end, int *result)</span><br><span class="line">&#123;</span><br><span class="line">    if (start &lt; end)</span><br><span class="line">    &#123;</span><br><span class="line">        int mid = start + (end-start) / 2;//避免溢出int</span><br><span class="line">        merge_sort(data, start, mid, result);                    //对左边进行排序</span><br><span class="line">        merge_sort(data, mid + 1, end, result);                  //对右边进行排序</span><br><span class="line">        merge(data, start, mid, end, result);                    //把排序好的数据合并</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void amalgamation(int *data1, int *data2, int *result)</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = 0; i &lt; 10; i++)</span><br><span class="line">        result[i] = data1[i];</span><br><span class="line">    for (int i = 0; i &lt; 10; i++)</span><br><span class="line">        result[i + 10] = data2[i];</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int data1[10] = &#123; 1,7,6,4,9,14,19,100,55,10 &#125;;</span><br><span class="line">    int data2[10] = &#123; 2,6,8,99,45,63,102,556,10,41 &#125;;</span><br><span class="line">    int *result = new int[20];                              </span><br><span class="line">    int *result1 = new int[20];</span><br><span class="line">    amalgamation(data1, data2, result);</span><br><span class="line">    for (int i = 0; i &lt; 20; ++i)</span><br><span class="line">        cout &lt;&lt; result[i] &lt;&lt; &quot;  &quot;;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    merge_sort(result, 0, 19, result1);</span><br><span class="line">    for (int i = 0; i &lt; 20; ++i)</span><br><span class="line">        cout &lt;&lt; result[i] &lt;&lt; &quot;  &quot;;</span><br><span class="line">    delete[]result;</span><br><span class="line">    delete[]result1;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h4><p>&emsp;&emsp;如果在面试中有面试官要求你写一个O(n)时间复杂度的排序算法，你千万不要立刻说：这不可能！虽然前面基于比较的排序的下限是O(nlogn)。但是确实也有线性时间复杂度的排序，只不过有前提条件，就是待排序的数要满足一定的范围的整数，而且计数排序需要比较多的辅助空间。其基本思想是，用待排序的数作为计数数组的下标，统计每个数字的个数。然后依次输出即可得到有序序列。<br>java实现代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *@Description:&lt;p&gt;计数排序算法实现&lt;/p&gt;</span><br><span class="line"> *@author Eric Zhang</span><br><span class="line"> *@time 2018-11-17 下午17：31：39</span><br><span class="line"> */</span><br><span class="line">public class CountSort &#123;</span><br><span class="line"></span><br><span class="line">    public static void countSort(int[] arr) &#123;</span><br><span class="line">        if(arr == null || arr.length == 0)</span><br><span class="line">            return ;</span><br><span class="line">        int max = max(arr);</span><br><span class="line">        int[] count = new int[max+1];</span><br><span class="line">        Arrays.fill(count, 0);</span><br><span class="line">        </span><br><span class="line">        for(int i=0; i&lt;arr.length; i++) &#123;</span><br><span class="line">            count[arr[i]] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        int k = 0;</span><br><span class="line">        for(int i=0; i&lt;=max; i++) &#123;</span><br><span class="line">            for(int j=0; j&lt;count[i]; j++) &#123;</span><br><span class="line">                arr[k++] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static int max(int[] arr) &#123;</span><br><span class="line">        int max = Integer.MIN_VALUE;</span><br><span class="line">        for(int ele : arr) &#123;</span><br><span class="line">            if(ele &gt; max)</span><br><span class="line">                max = ele;</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>C++实现代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN = 100000;</span><br><span class="line">const int k = 1000; // range</span><br><span class="line">int a[MAXN], c[MAXN], ranked[MAXN];</span><br><span class="line"> </span><br><span class="line">int main() &#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; a[i]; </span><br><span class="line">        ++c[a[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt; k; ++i)</span><br><span class="line">        c[i] += c[i-1];</span><br><span class="line">    for (int i = n-1; i &gt;= 0; --i)</span><br><span class="line">        ranked[--c[a[i]]] = a[i];//如果是i表达的是原数标号，a[i]就是排序后的正确序列</span><br><span class="line">    for (int i = 0; i &lt; n; ++i)</span><br><span class="line">        cout &lt;&lt; ranked[i] &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

            <div class="post-copyright">
    <div class="content">
        <p>最后更新： 2018年11月17日 17:31</p>
        <p>原始链接： <a class="post-url" href="/2018/11/17/sorting_Algorithm/" title="经典排序算法（持续更新）">http://excu4fun.com/2018/11/17/sorting_Algorithm/</a></p>
        <footer>
            <a href="http://excu4fun.com">
                <img src="/images/logo.png" alt="Eric Zhang">
                Eric Zhang
            </a>
        </footer>
    </div>
</div>

      
        
            
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;">赏</a>
</div>

<div id="reward" class="post-modal reward-lay">
    <a class="close" href="javascript:;" id="reward-close">×</a>
    <span class="reward-title">
        <i class="icon icon-quote-left"></i>
        请我吃糖~
        <i class="icon icon-quote-right"></i>
    </span>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/images/wechat_code.jpg" alt="打赏二维码">
        </div>
        <div class="reward-select">
            
            <label class="reward-select-item checked" data-id="wechat" data-wechat="/images/wechat_code.jpg">
                <img class="reward-select-item-wechat" src="/images/wechat.png" alt="微信">
            </label>
            
            
            <label class="reward-select-item" data-id="alipay" data-alipay="/images/alipay_code.jpg">
                <img class="reward-select-item-alipay" src="/images/alipay.png" alt="支付宝">
            </label>
            
        </div>
    </div>
</div>


        
    </div>
    <footer class="article-footer">
        
        
<div class="post-share">
    <a href="javascript:;" id="share-sub" class="post-share-fab">
        <i class="fa fa-share-alt"></i>
    </a>
    <div class="post-share-list" id="share-list">
        <ul class="share-icons">
          <li>
            <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://excu4fun.com/2018/11/17/sorting_Algorithm/&title=《经典排序算法（持续更新）》 — excu4funEric&pic=/images/sorting_Algorithm.png" data-title="微博">
              <i class="fa fa-weibo"></i>
            </a>
          </li>
          <li>
            <a class="weixin share-sns" id="wxFab" href="javascript:;" data-title="微信">
              <i class="fa fa-weixin"></i>
            </a>
          </li>
          <li>
            <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://excu4fun.com/2018/11/17/sorting_Algorithm/&title=《经典排序算法（持续更新）》 — excu4funEric&source=" data-title="QQ">
              <i class="fa fa-qq"></i>
            </a>
          </li>
          <li>
            <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://excu4fun.com/2018/11/17/sorting_Algorithm/" data-title="Facebook">
              <i class="fa fa-facebook"></i>
            </a>
          </li>
          <li>
            <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《经典排序算法（持续更新）》 — excu4funEric&url=http://excu4fun.com/2018/11/17/sorting_Algorithm/&via=http://excu4fun.com" data-title="Twitter">
              <i class="fa fa-twitter"></i>
            </a>
          </li>
          <li>
            <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://excu4fun.com/2018/11/17/sorting_Algorithm/" data-title="Google+">
              <i class="fa fa-google-plus"></i>
            </a>
          </li>
        </ul>
     </div>
</div>
<div class="post-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;" id="wxShare-close">×</a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=http://excu4fun.com/2018/11/17/sorting_Algorithm/" alt="微信分享二维码">
</div>

<div class="mask"></div>

        
        <ul class="article-footer-menu">
            
            
  <li class="article-footer-tags">
    <i class="fa fa-tags"></i>
      
    <a href="/tags/算法/" class="color3">算法</a>
      
  </li>

        </ul>
        
    </footer>
  </div>
</article>


    <aside class="post-toc-pos post-toc-top" id="post-toc">
        <nav class="post-toc-wrap">
            <ol class="post-toc"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#经典排序算法特征总结："><span class="post-toc-text">经典排序算法特征总结：</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#冒泡排序"><span class="post-toc-text">冒泡排序</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#选择排序"><span class="post-toc-text">选择排序</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#插入排序"><span class="post-toc-text">插入排序</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#快速排序"><span class="post-toc-text">快速排序</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#堆排序"><span class="post-toc-text">堆排序</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#希尔排序"><span class="post-toc-text">希尔排序</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#归并排序"><span class="post-toc-text">归并排序</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#计数排序"><span class="post-toc-text">计数排序</span></a></li></ol>
        </nav>
    </aside>
    

<nav id="article-nav">
  
    <a href="/2018/11/17/Linux_com/" id="article-nav-newer" class="article-nav-link-wrap">

      <span class="article-nav-title">
        <i class="fa fa-hand-o-left" aria-hidden="true"></i>
        
          Linux常用命令
        
      </span>
    </a>
  
  
    <a href="/2018/11/15/grammar_oc1/" id="article-nav-older" class="article-nav-link-wrap">
      <span class="article-nav-title">OC笔记（三）</span>
      <i class="fa fa-hand-o-right" aria-hidden="true"></i>
    </a>
  
</nav>



    
        <section id="comments">
            <div id="disqus_thread">
                <script type="text/javascript">
                    var disqus_shortname = 'true';
                    (function() {
                        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                    })();
                </script>
                <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
            </div>
        </section>
    
</section>
        
      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info" class="inner">
      
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


      <p>
        Powered by  <a href="http://hexo.io/" target="_blank">Hexo</a>
        Theme <a href="//github.com/wongminho/hexo-theme-miho" target="_blank">MiHo</a>
      &copy; 2018 Eric Zhang<br>
      </p>
    </div>
  </div>
</footer>
    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
<script>
  var mihoConfig = {
      root: "http://excu4fun.com",
      animate: true,
      isHome: false,
      share: true,
      reward: 1
  }
</script>
<div class="sidebar">
    <div id="sidebar-search" title="Search">
        <i class="fa fa-search"></i>
    </div>
    <div id="sidebar-category" title="Categories">
        <i class="fa fa-book"></i>
    </div>
    <div id="sidebar-tag" title="Tags">
        <i class="fa fa-tags"></i>
    </div>
    <div id="sidebar-top">
        <span class="sidebar-top-icon"><i class="fa fa-angle-up"></i></span>
    </div>
</div>
<div class="sidebar-menu-box" id="sidebar-menu-box">
    <div class="sidebar-menu-box-container">
        <div id="sidebar-menu-box-categories">
            <a class="category-link" href="/categories/Android/">Android</a><a class="category-link" href="/categories/IOS/">IOS</a><a class="category-link" href="/categories/Linux/">Linux</a><a class="category-link" href="/categories/Markdown/">Markdown</a><a class="category-link" href="/categories/排序算法/">排序算法</a><a class="category-link" href="/categories/文摘/">文摘</a><a class="category-link" href="/categories/闲话/">闲话</a>
        </div>
        <div id="sidebar-menu-box-tags">
            <a href="/tags/Android/" style="font-size: 10px;">Android</a> <a href="/tags/Cocos2d-x/" style="font-size: 10px;">Cocos2d-x</a> <a href="/tags/IOS/" style="font-size: 20px;">IOS</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/Markdown/" style="font-size: 10px;">Markdown</a> <a href="/tags/文摘/" style="font-size: 15px;">文摘</a> <a href="/tags/算法/" style="font-size: 10px;">算法</a> <a href="/tags/闲话/" style="font-size: 10px;">闲话</a>
        </div>
    </div>
    <a href="javascript:;" class="sidebar-menu-box-close">&times;</a>
</div>
<div class="mobile-header-menu-nav" id="mobile-header-menu-nav">
    <div class="mobile-header-menu-container">
        <span class="title">Menus</span>
        <ul class="mobile-header-menu-navbar">
            
            <li>
                <a  href="/">
                    <i class="fa fa-home"></i><span>Home</span>
                </a>
            </li>
            
            <li>
                <a  href="/archives">
                    <i class="fa fa-archive"></i><span>Archives</span>
                </a>
            </li>
            
            <li>
                <a  href="/about">
                    <i class="fa fa-user"></i><span>About</span>
                </a>
            </li>
            
        </ul>
    </div>
    <div class="mobile-header-tag-container">
        <span class="title">Tags</span>
        <div id="mobile-header-container-tags">
            <a href="/tags/Android/" style="font-size: 10px;">Android</a> <a href="/tags/Cocos2d-x/" style="font-size: 10px;">Cocos2d-x</a> <a href="/tags/IOS/" style="font-size: 20px;">IOS</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/Markdown/" style="font-size: 10px;">Markdown</a> <a href="/tags/文摘/" style="font-size: 15px;">文摘</a> <a href="/tags/算法/" style="font-size: 10px;">算法</a> <a href="/tags/闲话/" style="font-size: 10px;">闲话</a>
        </div>
    </div>
</div>
<div class="search-wrap">
    <span class="search-close">&times;</span>
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
            <i class="icon icon-lg icon-chevron-left"></i>
        </a>
        <input class="search-field" placeholder="Search..." id="keywords">
        <a id="search-submit" href="javascript:;">
            <i class="fa fa-search"></i>
        </a>
    <div class="search-container" id="search-container">
        <ul class="search-result" id="search-result">
        </ul>
    </div>
</div>

<div id="search-tpl">
    <li class="search-result-item">
        <a href="{url}" class="search-item-li">
            <span class="search-item-li-title" title="{title}">{title}</span>
        </a>
    </li>
</div>
<script src="/js/search.js"></script>
<script src="/js/main.js"></script>


  <script src="//cdn.bootcss.com/particles.js/2.0.0/particles.min.js"></script>
  <div id="particles"></div>
  <script src="/js/particles.js"></script>







  <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">
  <script src="//cdn.bootcss.com/scrollReveal.js/3.0.5/scrollreveal.js"></script>
  <script src="/js/animate.js"></script>


  <script src="/js/pop-img.js"></script>
  <script>
     $(".article-entry p img").popImg();
  </script>

  </div>
</body>
</html>