{"meta":{"title":"excu4funEric","subtitle":null,"description":null,"author":"Eric Zhang","url":"http://excu4fun.com"},"pages":[],"posts":[{"title":"OC笔记（一）","slug":"NSDictionary","date":"2018-11-14T16:00:00.000Z","updated":"2018-11-15T11:45:08.788Z","comments":true,"path":"2018/11/15/NSDictionary/","link":"","permalink":"http://excu4fun.com/2018/11/15/NSDictionary/","excerpt":"","text":"&emsp;&emsp;因为这几天再做有关ios相关的工作，发现json的数据格式与OC中的字典和数组很像，代码中经常用字典来接收解析服务器端请求活来的json数据，在此记录一下不可变字典（NSDictionary）与可变字典(NSMutableDictionary)的一些基本用法。 不可变字典（NSDictionary）与可变字典(NSMutableDictionary) 一、不可变字典(NSDictionary)1)初始化方法创建1NSDictionary *dic1 = [[NSDictionary alloc] initWithObjectsAndKeys:@&quot;张三&quot;, @&quot;name&quot;, @&quot;man&quot;, @&quot;gender&quot;, @&quot;22&quot;, @&quot;age&quot;, nil]; 2)便利构造器创建1NSDictionary *dic2 = [NSDictionary dictionaryWithObjectsAndKeys:@&quot;Chengdu&quot;, @&quot;city&quot;, @&quot;178&quot;, @&quot;height&quot;,@&quot;120&quot;, @&quot;weight&quot;, nil]; 3)字面量方式1NSDictionary *dic3 = @&#123;@&quot;date&quot; : @&quot;2018-11-15&quot;, @&quot;content&quot; : @&quot;Winter&quot;, @&quot;imageURL&quot; : @&quot;www.excu4fun.com/image/winter.png&quot;&#125;; 字典无序，键值对不分先后。 二、字典常用方法12345678910111213141516171819// 1) 获取字典中键值对个数NSUInteger num = [dic1 count];NSLog(@&quot;%lu&quot;, num);// 2) 获取字典中所有的键NSArray *array = dic1.allKeys; // [dic1 allKeys]NSLog(@&quot;%@&quot;, array);// 3) 获取字典中所有的值NSArray *array2 = [dic1 allValues]; // dic1.allValuesNSLog(@&quot;%@&quot;, array2);// 4) 获取指定的key所对应的valueNSString *str = [dic2 objectForKey:@&quot;image&quot;];NSLog(@&quot;%@&quot;,str); 三、可变字典的创建1)初始化方法创建1NSMutableDictionary *dic1 = [[NSMutableDictionary alloc] initWithObjectsAndKeys:@&quot;Reus&quot;, @&quot;name&quot;, @&quot;29&quot;, @&quot;age&quot;, @&quot;LWN&quot;, @&quot;location&quot;, nil]; 2)便利构造器创建1NSMutableDictionary *dic2 = [NSMutableDictionary dictionaryWithObjectsAndKeys:@&quot;Götze&quot;, @&quot;name&quot;, @&quot;Dortmund&quot;, @&quot;team&quot;, @&quot;AMC&quot;, @&quot;location&quot;, nil]; 3)字面量方式1NSMutableDictionary *dic3 = [@&#123;@&quot;姓名&quot; : @&quot;武磊&quot;, @&quot;位置&quot; : @&quot;前锋&quot;, @&quot;年龄&quot; : @&quot;27&quot;&#125; mutableCopy]; 四、可变字典的方法12345678910111213// 1) 根据 Key 值修改 value[dic3 setObject:@&quot;周鹏&quot; forKey:@&quot;姓名1&quot;]; // 本方法不仅可以修改已经存在的key的value,还可以添加新的 键值对儿.NSLog(@&quot;%@&quot;, [dic3 objectForKey:@&quot;姓名&quot;]);// 2) 移除指定key的键值对儿[dic3 removeObjectForKey:@&quot;姓名1&quot;];NSLog(@&quot;%@&quot;, dic3);// 3) 移除所有键值对儿[dic3 removeAllObjects];NSLog(@&quot;%@&quot;, dic3);","categories":[{"name":"IOS","slug":"IOS","permalink":"http://excu4fun.com/categories/IOS/"}],"tags":[{"name":"IOS","slug":"IOS","permalink":"http://excu4fun.com/tags/IOS/"}]},{"title":"OC笔记（二）","slug":"typeConversion","date":"2018-11-14T16:00:00.000Z","updated":"2018-11-15T12:07:12.291Z","comments":true,"path":"2018/11/15/typeConversion/","link":"","permalink":"http://excu4fun.com/2018/11/15/typeConversion/","excerpt":"","text":"一、NSString转化为UNICODE String12345(NSString*)fname ＝ @“Test”;char fnameStr[10];memcpy(fnameStr, [fname cStringUsingEncoding:NSUnicodeStringEncoding], 2*([fname length]));//memcpy并不是遇到&apos;\\0&apos;就结束，而是一定会拷贝完n个字节 二、NSString 与 char *互相转化123456//NSString 转化为 char *NSString * str＝ @“Test”;const char * a =[str UTF8String];//char * 转化为 NSStringNSString *str=[NSString stringWithCString encoding:NSUTF8StringEncoding]; 三、char * 与 NSData互相转化1234567891011//char * 转化 NSData方法一：char * a = (char*)malloc(sizeof(byte)*16);NSData *data = [NSData dataWithBytes: a length:strlen(a)];//char * 转化 NSData方法二：- (id)initWithUTF8String:(const char *)bytes //转换为NSString- (NSData *)dataUsingEncoding:(NSStringEncoding)encoding // 然后用NSString的//NSData 转化 char *NSData data ；char* a=[data bytes]; 四、NsData 与 NSString互相转化123456//NSData 转化 NSStringNSData* data;NSString* aStr= ［NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];//NSString 转化 NSData对象NSData* xmlData = [@&quot;testdata&quot; dataUsingEncoding:NSUTF8StringEncoding]; 五、 NSString输出CGPoint123UIButton *buttn=[UIButtonbuttonWithType:UIButtonTypeRoundedRect];buttn.frame=CGRectMake(0, 2, 100, 100);NSLog(@&quot;===%@&quot;,NSStringFromCGRect(buttn.frame)); //输出CGpoint和CGrect 六、 中文与utf8相互转换123456NSString *str=@&quot;老大-老二&quot;;NSString *ss=[str stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding]; //向网络传中文字符串要转换为utf8字符串再传,utf8码也是放在nsstring里的NSString *str2=[ss stringByReplacingPercentEscapesUsingEncoding:NSUTF8StringEncoding]; //utf8转换成中文字符串NSLog(@&quot;%@++\\n&quot;,str);NSLog(@&quot;%@--\\n&quot;,ss);NSLog(@&quot;%@==\\n&quot;,str2); 七、 NSString转换成NSArray1234NSArray *array=[str componentsSeparatedByString:@&quot;-&quot;]; for (int i=0; i&lt;2; i++) &#123; NSLog(@&quot;++%@++\\n&quot;,[array objectAtIndex:i]); &#125; 八、 NSString 与 NSURL互相转化12345678910111213141516171819202122232425262728293031323334353637383940414243//NSString 转化 NSURL NSString *urlString=[@&quot;http://www.google.com/search?client=safari&amp;rls=en&amp;q=搜索&amp;ie=UTF-8&amp;oe=UTF-8&quot;stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];NSURL *url = [NSURL URLWithString:urlString];//NSURL 转化 NSStringNSString *s=[[url absoluteString] stringByReplacingPercentEscapesUsingEncoding:NSUTF8StringEncoding];NSArray *arr = [urlString componentsSeparatedByString:@&quot;&amp;&quot;]; NSURL *url = [NSURL URLWithString:[[arr objectAtIndex:0] stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding ]]; NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url]; [request setHTTPMethod:@&quot;POST&quot;]; NSMutableArray *_array = [[NSMutableArray alloc] initWithCapacity:0]; for (int i = 1; i &lt; [arr count]; ++i )&#123; NSString *str = [arr objectAtIndex:i]; [_array addObject:str]; &#125; [_array componentsJoinedByString:@&quot;&amp;&quot;]; NSData *data = [[_array componentsJoinedByString:@&quot;&amp;&quot;] dataUsingEncoding: NSASCIIStringEncoding]; [request setHTTPBody:data];// 发送请求并获得服务器反馈的数据NSData *urldata = [AESEnCDeCViewController Get:url];// 第一种 转换NSData数据到char*字符串char * test = (char*)[urldata bytes];std::string old = deaes(test);// 第二种 转换NSData到UTF8编码的NSString中再转换为char*字符串NSString *desStr = [[NSString alloc] initWithData:urldata encoding:NSUTF8StringEncoding];const char *desresult = [desStr UTF8String];std::string old = deaes(desresult); // 解密字字符串到明文NSString *oldstr = [[NSString alloc] initWithCString:old.c_str()];//很多时候软件读取的中文网页编码集是gb2312，所以显示出来的是乱码。这时需要将NSString文字编码转换1 NSURL *url = [NSURL URLWithString:urlStr];2 NSData *data = [NSData dataWithContentsOfURL:url]; 3 NSStringEncoding enc = CFStringConvertEncodingToNSStringEncoding(kCFStringEncodingGB_18030_2000); 4 NSString *retStr = [[NSString alloc] initWithData:data encoding:enc];","categories":[{"name":"IOS","slug":"IOS","permalink":"http://excu4fun.com/categories/IOS/"}],"tags":[{"name":"IOS","slug":"IOS","permalink":"http://excu4fun.com/tags/IOS/"}]},{"title":"Fight When it’s Time to Fight. Be Gracious When It’s Time to Give In.","slug":"fight_and_give_up","date":"2018-10-31T16:00:00.000Z","updated":"2018-11-01T12:45:17.457Z","comments":true,"path":"2018/11/01/fight_and_give_up/","link":"","permalink":"http://excu4fun.com/2018/11/01/fight_and_give_up/","excerpt":"","text":"原作： Mark Suster 翻译：马超 原文：Entrepreneur &emsp;&emsp;在我第一次创业的时候我非常好斗。在我看来整个世界好像就是一个战场，我无时无刻不在准备着战斗。与房东斗，与债主斗，与董事会斗，与各个你所能想到的群体斗。但是随着我不断的成长，我越来越发现找到一个共同点比不断的斗争更有好处。 &emsp;&emsp;有两个人经常在我身旁尽最大的努力让我冷却下来，他们是我的COO Stuart Lander和CFO David Lapter。Stuart也有些好斗因子，但是之前做过律师的他懂得谈判与和解比打一场持久的战斗要好的多。我记得我们经常达成的一条共识就是——如果一定要转身，那么就优雅的转身。于是我形成了自己的一个思想：如果我要去战斗，那么我会如虎如狼直至胜利；但是如果一定要转身，那么我也将优雅从容的转身。 &emsp;&emsp;虽然你觉得不符合常理，但是许多人就喜欢在转身放弃时令各方都不愉快。 &emsp;&emsp;这类人往往没有意识到：你转身放弃已经意味着你失败了一次，如果你还在转身的那一瞬间弄得大家都发指，那么你不仅已经失败了两次而且还让别人在背后骂你混蛋彻底毁掉你的形象。 &emsp;&emsp;公司的日常运营中就有许多类似的情况需要智慧处理。打个比方，你公司的一位高层员工要求加薪，而你不太喜欢他提出加薪的方式。你有许多种选择：礼貌拒绝，妥协答应。当然这不是本文的重点。本文想说的重点就是如果你确实打算妥协加薪，那么不要表现的像个怒发鬼或者小气鬼，你应该衷心的表达你对他们优秀工作的谢意。最差却又有许多人经常造成的后果就是自己给员工加了薪却还让员工指指骂骂。 &emsp;&emsp;需要优雅转身的情况太多了，朋友们可以各种去想。 &emsp;&emsp;今天下午发生的一件事就再次让我想到了人们是如何失败两次的： &emsp;&emsp;我住的酒店有两个游泳池，一个大人专用，一个允许小孩用。但是不幸的是小孩经常两边窜。我们打算去游泳的时候大人专用泳池就宣布暂时关闭，据说原因是有个小孩在里面拉了粑粑。我想既然已经拉了，你还有什么办法呢？ &emsp;&emsp;可是这时我边上的一位女士就不答应了。她嘟嘟嚷嚷着拉了粑粑也可以游泳，说：“一点小孩的粑粑不会伤害任何人吧？”我可以毫不夸张的说她在那里吵吵闹闹有半个小时。很明显，这位女士失败了两次，第一次是没游上泳，第二次是因为没游上泳引发的怒发冲冠。 &emsp;&emsp;就像在高速路上有车子突然插到你前面去一样，你又能做什么呢？再插到他前面去？和他飙车？那你自己也是在玩命。 &emsp;&emsp;生活中有许多事你要是走错了路，你就失败了两次。想清楚战斗和转身的不同。该战斗的时候就战斗，该转身的时候就转身，而且请务必保持优雅。","categories":[{"name":"文摘","slug":"文摘","permalink":"http://excu4fun.com/categories/文摘/"}],"tags":[{"name":"文摘","slug":"文摘","permalink":"http://excu4fun.com/tags/文摘/"}]},{"title":"学习新技术真的需要买书吗？","slug":"need-book","date":"2018-10-25T16:00:00.000Z","updated":"2018-10-26T03:09:41.435Z","comments":true,"path":"2018/10/26/need-book/","link":"","permalink":"http://excu4fun.com/2018/10/26/need-book/","excerpt":"","text":"&emsp;&emsp;IT行业，学习新技术，特别是像Android、ios开发这种每时每刻都在更新变化的技术，真的需要买书吗？ &emsp;&emsp;Android是开源的，本身就有很好的文档，如果看文档不过瘾，那直接看代码啊！学习这类东西，买书的话很不划算。写一本好的IT书籍需要花多长时间？一年？两年？五年？写出来之后还要校正排版印刷出版发行，等到你手里，书里的内容基本上也就过时了。几个月写出来的书能看吗？根据经验这类书都是翻译官方文档+复制原版示例代码而成。 &emsp;&emsp;记得以前大学的时候买过一本xxx开发指南，买过来看了两三天就丢抽屉里吃灰去了，完全没有看下去的欲望，现在已经不知道丢哪了。 &emsp;&emsp;所以，如果希望学习新技术，想破头在挑选买哪本书的朋友，先认真思考一下，真的有必要去买吗？特别是中文版。","categories":[{"name":"闲话","slug":"闲话","permalink":"http://excu4fun.com/categories/闲话/"}],"tags":[{"name":"闲话","slug":"闲话","permalink":"http://excu4fun.com/tags/闲话/"}]},{"title":"Markdown基础语法","slug":"mark-down","date":"2018-10-25T16:00:00.000Z","updated":"2018-10-27T02:59:27.941Z","comments":true,"path":"2018/10/26/mark-down/","link":"","permalink":"http://excu4fun.com/2018/10/26/mark-down/","excerpt":"","text":"前言：为什么你应该用Markdown写作? &emsp;&emsp;Markdown是一种纯文本格式的标记语言，这是它的优点之一，只要是支持Markdown的地方都恩能够获得相同的编辑效果，有利于文本迁移，方便写作者排版，相信以后越来越多的平台都将支持Markdown编辑模式。 一、标题&emsp;&emsp;在标题文字前面加#来表示这是一个标题，Markdown支持6级标题，示例：123456#这是一级标题##这是二级标题###这是三级标题####这是四级标题#####这是五级标题######这是六级标题 &emsp;&emsp;效果如下： 这是一级标题这是二级标题这是三级标题这是四级标题这是五级标题这是六级标题二、字体·加粗用两个*将要加粗的文字包括起来 ·斜体用一个*将要倾斜的文字包括起来 ·斜体加粗用三个*将要倾斜加粗的文字包括起来 ·删除线用两个~将要加删除线的文字包括起来 &emsp;&emsp;示例：1234**这是要加粗的文字***这是倾斜的文字****这是斜体加粗的文字***~~这是加删除线的文字~~ &emsp;&emsp;效果如下：这是要加粗的文字这是倾斜的文字这是斜体加粗的文字这是加删除线的文字 三、引用&emsp;&emsp;在要加引用的文字前加&gt;&emsp;&emsp;示例：1&gt;这是引用的内容 &emsp;&emsp;效果如下： 这是引用的内容 四、分割线&emsp;&emsp;使用三个或三个以上的-或*&emsp;&emsp;示例：1234-----------*********** 五、图片&emsp;&emsp;插入图片语法：1231.[图片描述](图片地址&quot;图片tittle&quot;)图片票数为图片下面显示的文字。图片title为图片标题，可省略。 &emsp;&emsp;示例：1![sea](http://wx4.sinaimg.cn/mw690/0060lm7Tly1fwlvcahj2jj31i610418d.jpg) &emsp;&emsp;效果如下： 六、超链接&emsp;&emsp;语法：1[链接名](链接地址) &emsp;&emsp;示例：1[excu4fun](https://excu4fun.com) &emsp;&emsp;效果如下：excu4fun 七、表格&emsp;&emsp;语法：123456|姓名|技能|排行|| - | - | - | |刘备|哭|老大||关羽|打|老二||张飞|骂|老三|第二行的-有一个就够，为了对齐可以多加了几个 &emsp;&emsp;效果如下： 姓名 技能 排行 刘备 哭 老大 关羽 打 老二 张飞 骂 老三 八、代码&emsp;&emsp;语法：&emsp;&emsp;单行代码：代码之间用`包括起来1`This is a example` &emsp;&emsp;代码块：代码之间用123456```(```)This is a exampleThis is a example(```)括号是省略内容，为了方便显示效果，实际使用去掉括号 &emsp;&emsp;效果：&emsp;&emsp;单行代码：This is a example&emsp;&emsp;代码块：12This is a exampleThis is a example 九、流程图&emsp;&emsp;示例：1234567891011(```)flowst=&gt;start: Startop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?e=&gt;Endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op(```)括号为防止转译，实际使用忽略 &emsp;&emsp;可使用Markdown文本编辑器来生成流程图，效果如下： 十、背景及字体&emsp;&emsp;语法：1234&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=#A9A9A9&gt;这是需要加背景颜色的文字&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;font color=#FFFF00 size=6&gt;这是字体&lt;/font&gt; &emsp;&emsp;效果如下： 这是需要加背景颜色的文字 这是字体 &emsp;&emsp;附上颜色名列表： 颜色名 十六进制颜色值 颜色 AliceBlue #F0F8FF rgb(240, 248, 255) AntiqueWhite #FAEBD7 rgb(250, 235, 215) Aqua #00FFFF rgb(0, 255, 255) Aquamarine #7FFFD4 rgb(127, 255, 212) Azure #F0FFFF rgb(240, 255, 255) Beige #F5F5DC rgb(245, 245, 220) Bisque #FFE4C4 rgb(255, 228, 196) Black #000000 rgb(0, 0, 0) BlanchedAlmond #FFEBCD rgb(255, 235, 205) Blue #0000FF rgb(0, 0, 255) BlueViolet #8A2BE2 rgb(138, 43, 226) Brown #A52A2A rgb(165, 42, 42) BurlyWood #DEB887 rgb(222, 184, 135) CadetBlue #5F9EA0 rgb(95, 158, 160) Chartreuse #7FFF00 rgb(127, 255, 0) Chocolate #D2691E rgb(0, 255, 255) Coral #FF7F50 rgb(255, 127, 80) CornflowerBlue #6495ED rgb(100, 149, 237) Cornsilk #FFF8DC rgb(255, 248, 220) Crimson #DC143C rgb(220, 20, 60) Cyan #00FFFF rgb(0, 255, 255) DarkBlue #00008B rgb(0, 0, 139) DarkCyan #008B8B rgb(0, 139, 139) DarkGoldenRod #B8860B rgb(184, 134, 11) DarkGray #A9A9A9 rgb(169, 169, 169) DarkGreen #006400 rgb(0, 100, 0) DarkKhaki #BDB76B rgb(189, 183, 107) DarkMagenta #8B008B rgb(139, 0, 139) DarkOliveGreen #556B2F rgb(85, 107, 47) Darkorange #FF8C00 rgb(255, 140, 0) DarkOrchid #9932CC rgb(153, 50, 204) DarkRed #8B0000 rgb(139, 0, 0) DarkSalmon #E9967A rgb(233, 150, 122) DarkSeaGreen #8FBC8F rgb(143, 188, 143) DarkSlateBlue #483D8B rgb(72, 61, 139) DarkSlateGray #2F4F4F rgb(47, 79, 79) DarkTurquoise #00CED1 rgb(0, 206, 209) DarkViolet #9400D3 rgb(148, 0, 211) DeepPink #FF1493 rgb(255, 20, 147) DeepSkyBlue #00BFFF rgb(0, 191, 255) DimGray #696969 rgb(105, 105, 105) DodgerBlue #1E90FF rgb(30, 144, 255) Feldspar #D19275 rgb(209, 146, 117) FireBrick #B22222 rgb(178, 34, 34) FloralWhite #FFFAF0 rgb(255, 250, 240) ForestGreen #228B22 rgb(34, 139, 34) Fuchsia #FF00FF rgb(255, 0, 255) Gainsboro #DCDCDC rgb(220, 220, 220) GhostWhite #F8F8FF rgb(248, 248, 255) Gold #FFD700 rgb(255, 215, 0) GoldenRod #DAA520 rgb(218, 165, 32) Gray #808080 rgb(128, 128, 128) Green #008000 rgb(0, 128, 0) GreenYellow #ADFF2F rgb(173, 255, 47) HoneyDew #F0FFF0 rgb(240, 255, 240) HotPink #FF69B4 rgb(255, 105, 180) IndianRed #CD5C5C rgb(205, 92, 92) Indigo #4B0082 rgb(75, 0, 130) Ivory #FFFFF0 rgb(255, 255, 240) Khaki #F0E68C rgb(240, 230, 140) Lavender #E6E6FA rgb(230, 230, 250) LavenderBlush #FFF0F5 rgb(255, 240, 245) LawnGreen #7CFC00 rgb(124, 252, 0) LemonChiffon #FFFACD rgb(255, 250, 205) LightBlue #ADD8E6 rgb(173, 216, 230) LightCoral #F08080 rgb(240, 128, 128) LightCyan #E0FFFF rgb(224, 255, 255) LightGoldenRodYellow #FAFAD2 rgb(250, 250, 210) LightGrey #D3D3D3 rgb(211, 211, 211) LightGreen #90EE90 rgb(144, 238, 144) Linen #FAF0E6 rgb(250, 240, 230) Magenta #FF00FF rgb(255, 0, 255) Maroon #800000 rgb(128, 0, 0) MediumAquaMarine #66CDAA rgb(102, 205, 170) MediumBlue #0000CD rgb(0, 0, 205) MediumOrchid #BA55D3 rgb(186, 85, 211) MediumPurple #9370D8 rgb(147, 112, 216) MediumSeaGreen #3CB371 rgb(60, 179, 113) MediumSlateBlue #7B68EE rgb(123, 104, 238) MediumSpringGreen #00FA9A rgb(0, 250, 154) MediumTurquoise #48D1CC rgb(72, 209, 204) MediumVioletRed #C71585 rgb(199, 21, 133) MidnightBlue #191970 rgb(25, 25, 112) MintCream #F5FFFA rgb(245, 255, 250) MistyRose #FFE4E1 rgb(255, 228, 225) Moccasin #FFE4B5 rgb(255, 228, 181) NavajoWhite #FFDEAD rgb(255, 222, 173) Navy #000080 rgb(0, 0, 128) OldLace #FDF5E6 rgb(253, 245, 230) Olive #808000 rgb(128, 128, 0) OliveDrab #6B8E23 rgb(107, 142, 35) Orange #FFA500 rgb(255, 165, 0) OrangeRed #FF4500 rgb(255, 69, 0) Orchid #DA70D6 rgb(218, 112, 214) PaleGoldenRod #EEE8AA rgb(238, 232, 170) PaleGreen #98FB98 rgb(152, 251, 152) PaleTurquoise #AFEEEE rgb(175, 238, 238) PaleVioletRed #D87093 rgb(216, 112, 147) PapayaWhip #FFEFD5 rgb(255, 239, 213) PeachPuff #FFDAB9 rgb(255, 218, 185) Peru #CD853F rgb(205, 133, 63) Pink #FFC0CB rgb(255, 192, 203) Plum #DDA0DD rgb(221, 160, 221) PowderBlue #B0E0E6 rgb(176, 224, 230) Purple #800080 rgb(128, 0, 128) Red #FF0000 rgb(255, 0, 0) RosyBrown #BC8F8F rgb(188, 143, 143) RoyalBlue #4169E1 rgb(65, 105, 225) SaddleBrown #8B4513 rgb(139, 69, 19) Salmon #FA8072 rgb(250, 128, 114) SandyBrown #F4A460 rgb(244, 164, 96) SeaGreen #2E8B57 rgb(46, 139, 87) SeaShell #FFF5EE rgb(255, 245, 238) Sienna #A0522D rgb(160, 82, 45) Silver #C0C0C0 rgb(192, 192, 192) SkyBlue #87CEEB rgb(135, 206, 235) SlateBlue #6A5ACD rgb(106, 90, 205) SlateGray #708090 rgb(112, 128, 144) Snow #FFFAFA rgb(255, 250, 250) SpringGreen #00FF7F rgb(0, 255, 127) SteelBlue #4682B4 rgb(70, 130, 180) Tan #D2B48C rgb(210, 180, 140) Teal #008080 rgb(0, 128, 128) Thistle #D8BFD8 rgb(216, 191, 216) Tomato #FF6347 rgb(255, 99, 71) Turquoise #40E0D0 rgb(64, 224, 208) Violet #EE82EE rgb(238, 130, 238) VioletRed #D02090 rgb(208, 32, 144) Wheat #F5DEB3 rgb(245, 222, 179) White #FFFFFF rgb(255, 255, 255) WhiteSmoke #F5F5F5 rgb(245, 245, 245) Yellow #FFFF00 rgb(255, 255, 0) YellowGreen #9ACD32 rgb(154, 205, 50)","categories":[{"name":"Markdown","slug":"Markdown","permalink":"http://excu4fun.com/categories/Markdown/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://excu4fun.com/tags/Markdown/"}]},{"title":"Time Or Money","slug":"time-or-money","date":"2018-10-21T16:00:00.000Z","updated":"2018-10-26T12:02:15.981Z","comments":true,"path":"2018/10/22/time-or-money/","link":"","permalink":"http://excu4fun.com/2018/10/22/time-or-money/","excerpt":"","text":"原作： J.D.Roth 翻译：翛凌 原文：Entrepreneur 关于作者J. D. Roth 《你的金钱：失落的使用手册》的作者。同时他也是个人金融博客 getrichslowly.org 的创立者和编辑。 &emsp;&emsp;「时间就是金钱，金钱就是时间」。这是 Joe Dominguez 和 Vicki Robin 合著的个人理财经典教程《你的金钱或你的时间》的中心思想。他们在书中写道，「金钱是我们选择通过耗费我们的能量这样一种方式来换取的东西。」 &emsp;&emsp;这两位作者的观点主要是这样的：你需要耗费时间才能获得金钱，因此你在买东西时花费的并不是你的金钱，而是你的时间。举例来说，假设你是一个一小时挣 50 美元的顾问，你买了一个价值 500 美元的 iPad。那么这个 iPad 实际上并不是花费了你 500 美元，而是耗费了你 10 小时的工作。如果你一小时只挣 25 美元，那么这个 iPad 实际上是时薪50美元的顾问的两倍，因为你需要工作 20 小时才能支付得起这个 iPad。 &emsp;&emsp;这种观点实际上有一些有力的实例。当你的花费变少的时候，你实际上可以工作得更少。节俭的人「买下」的时间比不节俭的人要多很多。 你的时间值多少钱？如果你是一个企业家，那么当你的生意越做越大的时候，你的时间也变得更为有价值。实际上你可以用一种非常简单的方式来计算你的时间的价值：假设你一周工作 h 小时，一年有 w 周。将你一整年的全部收入加起来，而后除以将你所有来源的收入加在一起，除以 ( h × w)，这就是你的时间所值的价钱。如果你需要做某件事情，计算一下究竟是你的时间更值钱还是请一个其他人做这个事情耗费的金钱更多。如果你的时间更值钱，那么就请人做这件事情。如果其他人的时间比较值钱，那么你还是自己来做这件事情吧。 &emsp;&emsp;实际上，有些精明的人已经发现了，极度节俭是一条能够让你实现提前退休的好方法。这再你的收入特别高的时尤为明显。如果你在二十多岁和三十多岁的时候能保证每月节省出至少一半甚至 70% 的工资时，你完全可以在 40 岁的时候退休，而不用像一般人一样 65 岁退休。 &emsp;&emsp;当然我们不可能每个人都适用这样的规律。但是从另一方面来说，金钱也可以买时间。Toni Anderson 又有一个叫做快乐主妇的网站。除了要管理这个逐渐扩大的网站，她还要照顾七个孩子。而她的丈夫，一名海军军官，却并不在她的身边，因此也无法帮助她照料事业和他们的七个孩子。Toni 也因此对时间和金钱之间的关系有着深刻的理解，所以在处理时间和金钱方面的平衡时非常有经验。 &emsp;&emsp;Toni 雇佣了以为助手去帮助她处理邮件并且帮助她整理生意上的一些细节（比如账单和募捐）。这样 Toni 就可以专注于处理她擅长的事情，也就是维持客户和消费者之间的关系。Toni 表示，「把你讨厌做的事情或者你不擅长做的事情委托给别人做就是其中的关键。」 &emsp;&emsp;像许多人一样，我花钱请了一个会计帮我管理我的税务问题。这不仅仅是因为他在这方面比我做得好、做得专业，而且还有个很重要的原因就是这只需要耗费他两个小时的时间。而如果要我自己处理这些问题，我可能需要 20 小时。同样，我还请了一个钟点工，每个月来我们家打扫两次房子。是的，请钟点工挺贵。不过这能让我花更多的时间去做那些我更擅长的、能拿到工资的工作。请钟点工能每个月让我多出几小时的空闲时间。而在这几小时内，我写了这篇文章。实际上，这篇文章的稿费够我请她在未来三个月内继续来我们家打扫卫生。 &emsp;&emsp;当然，在你刚开始一项事业的时候，比起金钱，你可能会拥有更多的时间。因此凡事亲力亲为、参与公司内的各项事务是非常合理的。但是一旦你的事业随着时间的推移逐渐做大，你的时间就会显得越来越少，而你的金钱则变得越来越多。此时花钱请一些员工去处理一些特定事情就变得非常有效。他们能帮助你分担一些你不擅长的工作，而你也能腾出更多时间处理你擅长的工作，获取更多的利润。 &emsp;&emsp;总结一下，在生活和工作上寻求平衡实际上就是平衡你使用金钱和使用时间的方式。如果买一个 iPad 只耗费你生命中 10 小时或者 20 小时的工作，那么买了 iPad 当然没有什么不可以。如果你需要工作更久的时间工作才能买得起这个 iPad ，那么请不要买这个 iPad 。就当帮自己一个忙：存下来这笔用来买 iPad 的钱。这样你以后就能早点退休，享受自己喜爱的生活了。","categories":[{"name":"文摘","slug":"文摘","permalink":"http://excu4fun.com/categories/文摘/"}],"tags":[{"name":"文摘","slug":"文摘","permalink":"http://excu4fun.com/tags/文摘/"}]},{"title":"Cocos2d-x3.10使用obb扩展包","slug":"android-obb","date":"2018-10-20T16:00:00.000Z","updated":"2018-10-22T07:06:27.466Z","comments":true,"path":"2018/10/21/android-obb/","link":"","permalink":"http://excu4fun.com/2018/10/21/android-obb/","excerpt":"","text":"一. 创建Obb文件并模拟下载环境1.1 Obb文件命名规则根据google官方的OBB文件命名规则来创建Obb文件：12&lt;main|patch&gt;.&lt;expansion-version&gt;.&lt;package-name&gt;.obb//例如：main.10001.com.demo.app.obb main|patch: main代表主扩展包，patch代表补充扩展包，一般只使用main关键字。expansion-version: 即version code。package-name: 包名。obb：后缀，本质为zip文件。 注意：上传google后台时，测试包的version code不能与正式包的version code相同，google不允许上传相同版本的app，即使其中一个是用来测试。 1.2 创建obb文件推荐使用winrar来创建obb文件，选择需要做成obb扩展包的资源文件，将其压缩，配置如下 注意：压缩文件格式选择”zip“，压缩方式选择”存储“ 1.3 本地模拟obb环境测试将创建好的obb文件放入手机sdcard/Android/obb/com.yourpackageName/目录下，如果本地没有相应目录，则手动创建即可（apk与obb上传google play后台之后，用户下载应用会自动创建相应目录）完成本地测试环境。 二. 修改引擎层代码Cocos2d-x3.16版本已添加读取obb文件功能，但3.16之前版本的则需要修改引擎部分代码才能读取obb文件 2.1 修改Java_org_cocos2dx_lib_Cocos2dxHelper.cpp在Java_org_cocos2dx_lib_Cocos2dxHelper.cpp中添加如下代码：1234567891011//添加obb pathstring g_obbPath//添加设置obbpath方法 JNIEXPORT void JNICALL Java_org_cocos2dx_lib_Cocos2dxHelper_nativeSetObbPath(JNIEnv* env, jobject thiz, jstring obbPath) &#123; g_obbPath = JniHelper::jstring2string(obbPath); &#125;//添加获取obbpath 方法const char * getObbPath()&#123; return g_obbPath.c_str();&#125; Java_org_cocos2dx_lib_Cocos2dxHelper.h中添加如下代码：12//添加方法extern const char * getObbPath(); 2.2 修改CCFileUtils-android.cpp在CCFileUtilsAndroid.h中添加：12#include \"base/ZipUtils.h\"//如要引入头文件，请确保Android.mk中配置了正确的路径 在CCFileUtilsAndroid.cpp中：12//创建全局指针变量obbFileZipFile *obbFile; 在构造函数FileUtilsAndroid::FileUtilsAndroid()中添加：1234FileUtilsAndroid::FileUtilsAndroid()&#123; obbFile = nullptr;&#125; 在析构函数FileUtilsAndroid::~FileUtilsAndroid()中添加：1234567FileUtilsAndroid::~FileUtilsAndroid()&#123; if(obbFile != nullptr) &#123; delete obbFile; obbFile = NULL; &#125;&#125; 有心的同学可以发现上述添加在之后的代码里中创建了一个单例模式 在isFileExistInternal()方法中做如下修改： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//引擎层代码不建议直接复制，建议与本地代码仔细比对后手动修改，注释部分用于方便看日志，可忽略bool FileUtilsAndroid::isFileExistInternal(const std::string&amp; strFilePath) const&#123; if (strFilePath.empty()) &#123; return false; &#125; bool bFound = false; // Check whether file exists in apk. if (strFilePath[0] != '/') &#123; const char* s = strFilePath.c_str(); // Found \"assets/\" at the beginning of the path and we dont want it if (strFilePath.find(_defaultResRootPath) == 0) s += strlen(\"assets/\"); if (FileUtilsAndroid::assetmanager) &#123; AAsset* aa = AAssetManager_open(FileUtilsAndroid::assetmanager, s, AASSET_MODE_UNKNOWN); if (aa) &#123; bFound = true; AAsset_close(aa); &#125;else&#123; if(getObbPath() != nullptr)&#123; // CCLOG(\"[AssetManager] ... in APK %s,%s, found = false! \\n obbPath=%s\", strFilePath.c_str(),s, getObbPath()); // ZipFile *obbFile = new ZipFile(getObbPath()); if (obbFile == nullptr) &#123; obbFile = new ZipFile(getObbPath()); &#125; if ( obbFile-&gt;fileExists(strFilePath.c_str()) ) &#123; // CCLOG(\"obb ... in APK %s, found = true!\", strFilePath.c_str()); bFound = true; // delete obbFile; // obbFile = NULL; &#125;else&#123; // CCLOG(\"obb ... in APK %s, found = false!\", strFilePath.c_str()); &#125; &#125; &#125; &#125; &#125; else &#123; FILE *fp = fopen(strFilePath.c_str(), \"r\"); if(fp) &#123; bFound = true; fclose(fp); &#125; &#125; return bFound;&#125; 在getData()方法中做如下修改： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123Data FileUtilsAndroid::getData(const std::string&amp; filename, bool forString)&#123; if (filename.empty()) &#123; return Data::Null; &#125; unsigned char* data = nullptr; ssize_t size = 0; string fullPath = fullPathForFilename(filename); if (fullPath[0] != '/') &#123; string relativePath = string(); size_t position = fullPath.find(\"assets/\"); if (0 == position) &#123; // \"assets/\" is at the beginning of the path and we dont want it relativePath += fullPath.substr(strlen(\"assets/\")); &#125; else &#123; relativePath += fullPath; &#125; LOGD(\"relative path = %s\", relativePath.c_str()); if (nullptr == FileUtilsAndroid::assetmanager) &#123; LOGD(\"... FileUtilsAndroid::assetmanager is nullptr\"); return Data::Null; &#125; // read asset data AAsset* asset = AAssetManager_open(FileUtilsAndroid::assetmanager, relativePath.c_str(), AASSET_MODE_UNKNOWN); if (nullptr != asset) &#123; off_t fileSize = AAsset_getLength(asset); if (forString) &#123; data = (unsigned char*) malloc(fileSize + 1); data[fileSize] = '\\0'; &#125; else &#123; data = (unsigned char*) malloc(fileSize); &#125; int bytesread = AAsset_read(asset, (void*)data, fileSize); size = bytesread; CCLOG(\"apk size test: size=%d;fileSize=%d\", size, fileSize); AAsset_close(asset); // return Data::Null; &#125;else&#123; CCLOG(\"asset is nullptr\"); ZipFile zipFile(getApkPath()); // CCLOG(\"guok special read: %s;forString=%d\", relativePath.c_str(), forString); string zFileNamePath = \"assets/\" + relativePath; // CCLOG(\"zFileNamePath =%s \",zFileNamePath.c_str()); // CCLOG(\"getObbPath() = %s\",getObbPath()); if ( zipFile.fileExists(zFileNamePath.c_str()) ) &#123; ssize_t fsize = 0 ; unsigned char* content = zipFile.getFileData(zFileNamePath.c_str(), &amp;fsize); // CCLOG(\"zipFile is exists!\"); if( fsize &gt; 0) &#123; // CCLOG(\"guok read success %d\", fsize); memcpy( data, content, fsize); size = fsize; &#125; else &#123; // CCLOG(\"guok read error %d\", fsize); &#125; if(content)free(content); &#125; else if(getObbPath() != nullptr)&#123; if (obbFile == nullptr) &#123; obbFile = new ZipFile(getObbPath()); &#125; // CCLOG(\"getObbPath() is exists!\"); string s = getObbPath(); string zObbNamePath = \"assets/\" + relativePath; // CCLOG(\"zObbNamePath = %s\",zObbNamePath.c_str()); if ( obbFile-&gt;fileExists(zObbNamePath.c_str()) ) &#123; ssize_t fsize = 0; unsigned char* content = obbFile-&gt;getFileData(zObbNamePath.c_str(), &amp;fsize); // CCLOG(\"obbFile is exists!\"); if( fsize &gt; 0) &#123; CCLOG(\"fsize = %d\",fsize); if (forString) &#123; data = (unsigned char*) malloc(fsize + 1); data[fsize] = '\\0'; // CCLOG(\"ssssssssssss\"); &#125;else&#123; data = (unsigned char*) malloc(fsize); // CCLOG(\"qqqqqqqqqqqqqqqqqqqq\"); &#125; memcpy( data, content, fsize); size = fsize; // CCLOG(\"obb getdata success %d\", fsize); &#125; else &#123; // CCLOG(\"obb getdata error %d\", fsize); &#125; if(content)free(content); &#125; &#125; if (size &lt;= 0) &#123; CCLOG(\"obb null size %d\", size); return Data::Null; &#125; &#125; &#125; else &#123; do &#123; ................... &#125; 在getFileData()方法中做如下修改： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114unsigned char* FileUtilsAndroid::getFileData(const std::string&amp; filename, const char* mode, ssize_t * size)&#123; unsigned char * data = 0; if ( filename.empty() || (! mode) ) &#123; return 0; &#125; string fullPath = fullPathForFilename(filename); if (fullPath[0] != '/') &#123; string relativePath = string(); size_t position = fullPath.find(\"assets/\"); if (0 == position) &#123; // \"assets/\" is at the beginning of the path and we dont want it relativePath += fullPath.substr(strlen(\"assets/\")); &#125; else &#123; relativePath += fullPath; &#125; LOGD(\"relative path = %s\", relativePath.c_str()); if (nullptr == FileUtilsAndroid::assetmanager) &#123; LOGD(\"... FileUtilsAndroid::assetmanager is nullptr\"); return nullptr; &#125; // read asset data AAsset* asset = AAssetManager_open(FileUtilsAndroid::assetmanager, relativePath.c_str(), AASSET_MODE_UNKNOWN); if (nullptr != asset) &#123; LOGD(\"asset is not nullptr\"); off_t fileSize = AAsset_getLength(asset); data = (unsigned char*) malloc(fileSize); int bytesread = AAsset_read(asset, (void*)data, fileSize); if (size) &#123; *size = bytesread; &#125; AAsset_close(asset); &#125; else &#123; LOGD(\"asset is nullptr\"); ZipFile zipFile(getApkPath()); CCLOG(\" special read: %s\", relativePath.c_str()); string zFileNamePath = \"assets/\" + relativePath; if ( zipFile.fileExists(zFileNamePath.c_str()) ) &#123; ssize_t fsize = 0; unsigned char* content = zipFile.getFileData(zFileNamePath.c_str(), &amp;fsize); if( fsize &gt; 0) &#123; // CCLOG(\"getfiledata success %d\", fsize); data = (unsigned char*) malloc(fsize); memcpy( data, content, fsize); if (size) &#123; *size = fsize; &#125; &#125; else &#123; CCLOG(\"getfiledata error %d\", fsize); &#125; if(content)free(content); &#125; else if(getObbPath() != nullptr)&#123; if (obbFile == nullptr) &#123; obbFile = new ZipFile(getObbPath()); &#125; string zObbNamePath = \"assets/\" + relativePath; // CCLOG(\"zObbNamePath = %s\",zObbNamePath.c_str()); if ( obbFile-&gt;fileExists(zObbNamePath.c_str()) ) &#123; ssize_t fsize = 0; unsigned char* content = obbFile-&gt;getFileData(zObbNamePath.c_str(), &amp;fsize); delete obbFile; obbFile = NULL; if( fsize &gt; 0) &#123; // CCLOG(\"obb getfiledata success %d\", fsize); data = (unsigned char*) malloc(fsize); memcpy( data, content, fsize); if (size) &#123; *size = fsize; &#125; &#125; else &#123; // CCLOG(\"obb getfiledata error %d\", fsize); &#125; if(content)free(content); &#125; &#125; &#125; if (!data) &#123; CCLOG(\"getFileData error: %s\", relativePath.c_str()); return nullptr; &#125; &#125; else &#123; do &#123; ................... &#125; 三. 修改安卓层代码准备工作：在Android Studio工程中导入google官方提供的库google_market_apk_expansion,具体可查看Android官方文档，所需的库可通过Android SDK Manager进行下载 3.1 在AndroidManifest.xml中配置相关权限123456&lt;uses-permission android:name=\"com.android.vending.CHECK_LICENSE\" /&gt;&lt;uses-permission android:name=\"android.permission.INTERNET\" /&gt;&lt;uses-permission android:name=\"android.permission.WAKE_LOCK\" /&gt;&lt;uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" /&gt;&lt;uses-permission android:name=\"android.permission.ACCESS_WIFI_STATE\"/&gt;&lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" / 3.2 在Cocos2dxActivity中添加变量及方法 123456789101112131415161718192021222324252627282930313233public static String FATE_OBB_PATH = \"\";public static String FATE_OBB_Name = \"\";@Override protected void onCreate(final Bundle savedInstanceState) &#123; FATE_OBB_Name = getObbFileName(); FATE_OBB_PATH = getVirtualObbFileFullpath(); super.onCreate(savedInstanceState); .... &#125; private String getObbFileName() &#123; PackageInfo info = null; try &#123; info = getPackageManager().getPackageInfo(getPackageName(), 0); String fileName = \"main.\" + info.versionCode + \".\" + getPackageName() + \".obb\"; Log.e(\"obb===fileName===\", fileName); return fileName; &#125; catch (NameNotFoundException e) &#123; e.printStackTrace(); &#125; return \"\"; &#125;private String getVirtualObbFileFullpath()&#123; String _path = \"\"; File file = getObbDir(); if(file == null || !file.exists())&#123; file.mkdirs(); &#125; _path = file.getPath() + \"/\" + getObbFileName(); Log.e(\"obb===_path===\", _path); return _path; &#125; 3.3 在Cocos2dxHelper中添加变量及方法 123public static ZipResourceFile obbzip = null;//使用需要外部依赖private static native void nativeSetObbPath(final String pObbPath);// nativeSetObbPath 设置obb路径方法 在init()中添加：12345678910111213141516171819202122232425262728293031323334353637383940public static void init(final Activity activity) &#123; if (!sInited) &#123; final ApplicationInfo applicationInfo = activity.getApplicationInfo(); Cocos2dxHelper.sCocos2dxHelperListener = (Cocos2dxHelperListener)activity; Cocos2dxHelper.sPackageName = applicationInfo.packageName; Cocos2dxHelper.sFileDirectory = activity.getFilesDir().getAbsolutePath(); Cocos2dxHelper.nativeSetApkPath(applicationInfo.sourceDir); Cocos2dxHelper.sCocos2dxAccelerometer = new Cocos2dxAccelerometer(activity); Cocos2dxHelper.sCocos2dMusic = new Cocos2dxMusic(activity); Cocos2dxHelper.sCocos2dSound = new Cocos2dxSound(activity); Cocos2dxHelper.sAssetManager = activity.getAssets(); if (fileIsExists(Cocos2dxActivity.FATE_OBB_PATH)) &#123; Cocos2dxHelper.nativeSetObbPath(Cocos2dxActivity.FATE_OBB_PATH); &#125; PackageInfo info = null; try &#123; info = activity.getPackageManager().getPackageInfo( activity.getPackageName(), 0); Cocos2dxHelper.obbzip = APKExpansionSupport .getAPKExpansionZipFile(activity, info.versionCode, 0); &#125; catch (PackageManager.NameNotFoundException e1) &#123; e1.printStackTrace(); &#125; catch (IOException e1) &#123; e1.printStackTrace(); &#125; Cocos2dxHelper.nativeSetContext((Context)activity, Cocos2dxHelper.sAssetManager); Cocos2dxBitmap.setContext(activity); Cocos2dxETCLoader.setContext(activity); sActivity = activity; sInited = true; &#125; &#125; 添加fileIsExists方法：123456789101112131415public static boolean fileIsExists(String strFile) &#123; if(strFile.isEmpty())&#123; return false; &#125; try &#123; File f = new File(strFile); if (!f.exists()) &#123; return false; &#125; &#125; catch (Exception e) &#123; return false; &#125; Log.d(\"obb\", \"file exist!\"); return true;&#125; 3.4 修改Cocos2dxMusic将1mediaPlayer.setDataSource(assetFileDescritor.getFileDescriptor(),assetFileDescritor.getStartOffset(), assetFileDescritor.getLength()); 替换为：12345678final AssetFileDescriptor assetFileDescritor = Cocos2dxHelper.obbzip.getAssetFileDescriptor(\"assets/\"+pPath); if(assetFileDescritor == null)&#123; final AssetFileDescriptor assetFileDescritor1 = this.mContext.getAssets().openFd(pPath); mediaPlayer.setDataSource(assetFileDescritor1.getFileDescriptor(), assetFileDescritor1.getStartOffset(), assetFileDescritor1.getLength()); &#125;else&#123; mediaPlayer.setDataSource(assetFileDescritor.getFileDescriptor(), assetFileDescritor.getStartOffset(), assetFileDescritor.getLength()); &#125; 3.5 修改Cocos2dxSound将1soundID = this.mSoundPool.load(this.mContext.getAssets().openFd(pPath), 0); 替换为：12345678910final AssetFileDescriptor assetFileDescritor = Cocos2dxHelper.obbzip .getAssetFileDescriptor(\"assets/\" + pPath); if (assetFileDescritor == null) &#123; final AssetFileDescriptor assetFileDescritor1 = this.mContext .getAssets().openFd(pPath); soundID = this.mSoundPool.load(assetFileDescritor1, 0); &#125; else &#123; soundID = this.mSoundPool.load(assetFileDescritor, 0); &#125; 3.6 在主Activity中添加代码12345678910111213141516171819private static final int REQUEST_EXTERNAL_STORAGE = 1;private static String[] PERMISSIONS_STORAGE = &#123; \"android.permission.READ_EXTERNAL_STORAGE\", \"android.permission.WRITE_EXTERNAL_STORAGE\" &#125;;public static void verifyStoragePermissions(Sprites activity) &#123; try &#123; //检测是否有写的权限 int permission = ActivityCompat.checkSelfPermission(activity, \"android.permission.WRITE_EXTERNAL_STORAGE\"); if (permission != PackageManager.PERMISSION_GRANTED) &#123; // 没有写的权限，去申请写的权限，弹出对话框 ActivityCompat.requestPermissions(activity, PERMISSIONS_STORAGE,REQUEST_EXTERNAL_STORAGE); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 在onCreate()中添加：12345678910111213141516171819202122232425262728293031323334//判断是否有sd卡读写权限，如果没有，则去申请！verifyStoragePermissions(Sprites.this); //检测是否已经下载到了obb包,如果没有，则弹出错误提示，killProcessif (Cocos2dxActivity.FATE_OBB_PATH.isEmpty() || !Cocos2dxHelper.fileIsExists(Cocos2dxActivity.FATE_OBB_PATH)) &#123; // 创建构建器 AlertDialog.Builder builder = new AlertDialog.Builder(this); // 设置参数 builder.setTitle(\"提示\").setIcon(R.drawable.icon) .setMessage(\"游戏资源已损坏，请重新下载！\") .setPositiveButton(\"退出\", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; // TODO Auto-generated method stub android.os.Process.killProcess(android.os.Process.myPid()); &#125; &#125;); builder.create().show(); new Handler().postDelayed(new Runnable()&#123; //延时3s退出程序 public void run() &#123; android.os.Process.killProcess(android.os.Process.myPid()); //execute the task &#125; &#125;, 3000); //如果未检测到obb包，延时3s后关闭程序&#125;/*这里最正确的方法应该是如果未检测到obb包，则去google后台手动下载，但这一部分的内容非常多而繁琐，在本篇中不进行详述，google官方表示不保证所有机型都可以下载得到obb包，因此需要添加手动下载的功能，通过公司的游戏实际检验，下载不到obb包的概率小于1%（当然这个统计不是很专业，也有可能有玩家没下载到obb包但没有反馈）如要添加此功能，需要依赖google配套的库，但是关于download方面的库年代已经很久远了，许多方法现在已经废弃，而google又一直没有升级过这个库，导致想要用需要自己手动去修改里面的n多错误，这将是件令人很头疼的问题，如果有时间，我会在之后的blog中记录如何实现这一过程*/ 总结完成以上修改之后，就可以先将obb包copy到手机相关目录下进行本地测试，没有问题就可以上传google beta测试包到googleplay后台去进行相关测试了，这部分内容是大学毕业进入公司后接手的第一个项目，全部完成用了一周的时间，之前公司一直是使用热更的方法来应对google的100Mapk上传限制，导致玩家每次都要下载一个很大的更新包，影响游戏体验，因此公司决定使用obb分包的方式上传apk，在此还要感谢老陈对我这个刚来的菜鸟的信任，将这份任务交给我，此致。","categories":[{"name":"Android","slug":"Android","permalink":"http://excu4fun.com/categories/Android/"}],"tags":[{"name":"Cocos2d-x","slug":"Cocos2d-x","permalink":"http://excu4fun.com/tags/Cocos2d-x/"},{"name":"Android","slug":"Android","permalink":"http://excu4fun.com/tags/Android/"}]}]}