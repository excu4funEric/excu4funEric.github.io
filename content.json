{"meta":{"title":"excu4funEric","subtitle":null,"description":null,"author":"Eric Zhang","url":"http://excu4fun.com"},"pages":[],"posts":[{"title":"Linux常用命令","slug":"Linux_com","date":"2018-11-16T16:00:00.000Z","updated":"2018-11-17T06:32:02.665Z","comments":true,"path":"2018/11/17/Linux_com/","link":"","permalink":"http://excu4fun.com/2018/11/17/Linux_com/","excerpt":"","text":"系统信息12345678910111213141516171819arch 显示机器的处理器架构(1) uname -m 显示机器的处理器架构(2) uname -r 显示正在使用的内核版本 dmidecode -q 显示硬件系统部件 - (SMBIOS / DMI) hdparm -i /dev/hda 罗列一个磁盘的架构特性 hdparm -tT /dev/sda 在磁盘上执行测试性读取操作 cat /proc/cpuinfo 显示CPU info的信息 cat /proc/interrupts 显示中断 cat /proc/meminfo 校验内存使用 cat /proc/swaps 显示哪些swap被使用 cat /proc/version 显示内核的版本 cat /proc/net/dev 显示网络适配器及统计 cat /proc/mounts 显示已加载的文件系统 lspci -tv 罗列 PCI 设备 lsusb -tv 显示 USB 设备 date 显示系统日期 cal 2007 显示2007年的日历表 date 041217002007.00 设置日期和时间 - 月日时分年.秒 clock -w 将时间修改保存到 BIOS 关机 (系统的关机、重启以及登出 )12345678shutdown -h now 关闭系统(1) init 0 关闭系统(2) telinit 0 关闭系统(3) shutdown -h hours:minutes &amp; 按预定时间关闭系统 shutdown -c 取消按预定时间关闭系统 shutdown -r now 重启(1) reboot 重启(2) logout 注销 文件和目录12345678910111213141516171819202122232425262728293031cd /home 进入 &apos;/ home&apos; 目录&apos; cd .. 返回上一级目录 cd ../.. 返回上两级目录 cd 进入个人的主目录 cd ~user1 进入个人的主目录 cd - 返回上次所在的目录 pwd 显示工作路径 ls 查看目录中的文件 ls -F 查看目录中的文件 ls -l 显示文件和目录的详细资料 ls -a 显示隐藏文件 ls *[0-9]* 显示包含数字的文件名和目录名 tree 显示文件和目录由根目录开始的树形结构(1) lstree 显示文件和目录由根目录开始的树形结构(2) mkdir dir1 创建一个叫做 &apos;dir1&apos; 的目录&apos; mkdir dir1 dir2 同时创建两个目录 mkdir -p /tmp/dir1/dir2 创建一个目录树 rm -f file1 删除一个叫做 &apos;file1&apos; 的文件&apos; rmdir dir1 删除一个叫做 &apos;dir1&apos; 的目录&apos; rm -rf dir1 删除一个叫做 &apos;dir1&apos; 的目录并同时删除其内容 rm -rf dir1 dir2 同时删除两个目录及它们的内容 mv dir1 new_dir 重命名/移动 一个目录 cp file1 file2 复制一个文件 cp dir/* . 复制一个目录下的所有文件到当前工作目录 cp -a /tmp/dir1 . 复制一个目录到当前工作目录 cp -a dir1 dir2 复制一个目录 ln -s file1 lnk1 创建一个指向文件或目录的软链接 ln file1 lnk1 创建一个指向文件或目录的物理链接 touch -t 0712250000 file1 修改一个文件或目录的时间戳 - (YYMMDDhhmm) file file1 outputs the mime type of the file as text iconv -l 列出已知的编码 文件搜索12345678910find / -name file1 从 &apos;/&apos; 开始进入根文件系统搜索文件和目录 find / -user user1 搜索属于用户 &apos;user1&apos; 的文件和目录 find /home/user1 -name \\*.bin 在目录 &apos;/ home/user1&apos; 中搜索带有&apos;.bin&apos; 结尾的文件 find /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件 find /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件 find / -name \\*.rpm -exec chmod 755 &apos;&#123;&#125;&apos; \\; 搜索以 &apos;.rpm&apos; 结尾的文件并定义其权限 find / -xdev -name \\*.rpm 搜索以 &apos;.rpm&apos; 结尾的文件，忽略光驱、捷盘等可移动设备 locate \\*.ps 寻找以 &apos;.ps&apos; 结尾的文件 - 先运行 &apos;updatedb&apos; 命令 whereis halt 显示一个二进制文件、源码或man的位置 which halt 显示一个二进制文件或可执行文件的完整路径 挂载一个文件系统123456789101112mount /dev/hda2 /mnt/hda2 挂载一个叫做hda2的盘 - 确定目录 &apos;/ mnt/hda2&apos; 已经存在 umount /dev/hda2 卸载一个叫做hda2的盘 - 先从挂载点 &apos;/ mnt/hda2&apos; 退出 fuser -km /mnt/hda2 当设备繁忙时强制卸载 umount -n /mnt/hda2 运行卸载操作而不写入 /etc/mtab 文件- 当文件为只读或当磁盘写满时非常有用 mount /dev/fd0 /mnt/floppy 挂载一个软盘 mount /dev/cdrom /mnt/cdrom 挂载一个cdrom或dvdrom mount /dev/hdc /mnt/cdrecorder 挂载一个cdrw或dvdrom mount /dev/hdb /mnt/cdrecorder 挂载一个cdrw或dvdrom mount -o loop file.iso /mnt/cdrom 挂载一个文件或ISO镜像文件 mount -t vfat /dev/hda5 /mnt/hda5 挂载一个Windows FAT32文件系统 mount /dev/sda1 /mnt/usbdisk 挂载一个usb 捷盘或闪存设备 mount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share 挂载一个windows网络共享 磁盘空间123456df -h 显示已经挂载的分区列表 ls -lSr |more 以尺寸大小排列文件和目录 du -sh dir1 估算目录 &apos;dir1&apos; 已经使用的磁盘空间&apos; du -sk * | sort -rn 以容量大小为依据依次显示文件和目录的大小 rpm -q -a --qf &apos;%10&#123;SIZE&#125;t%&#123;NAME&#125;n&apos; | sort -k1,1n 以大小为依据依次显示已安装的rpm包所使用的空间 (fedora, redhat类系统) dpkg-query -W -f=&apos;$&#123;Installed-Size;10&#125;t$&#123;Package&#125;n&apos; | sort -k1,1n 以大小为依据显示已安装的deb包所使用的空间 (ubuntu, debian类系统) 用户和群组12345678910111213groupadd group_name 创建一个新用户组 groupdel group_name 删除一个用户组 groupmod -n new_group_name old_group_name 重命名一个用户组 useradd -c &quot;Name Surname &quot; -g admin -d /home/user1 -s /bin/bash user1 创建一个属于 &quot;admin&quot; 用户组的用户 useradd user1 创建一个新用户 userdel -r user1 删除一个用户 ( &apos;-r&apos; 排除主目录) usermod -c &quot;User FTP&quot; -g system -d /ftp/user1 -s /bin/nologin user1 修改用户属性 passwd 修改口令 passwd user1 修改一个用户的口令 (只允许root执行) chage -E 2005-12-31 user1 设置用户口令的失效期限 pwck 检查 &apos;/etc/passwd&apos; 的文件格式和语法修正以及存在的用户 grpck 检查 &apos;/etc/passwd&apos; 的文件格式和语法修正以及存在的群组 newgrp group_name 登陆进一个新的群组以改变新创建文件的预设群组 文件的权限 - 使用 “+” 设置权限，使用 “-“ 用于取消123456789101112131415ls -lh 显示权限 ls /tmp | pr -T5 -W$COLUMNS 将终端划分成5栏显示 chmod ugo+rwx directory1 设置目录的所有人(u)、群组(g)以及其他人(o)以读（r ）、写(w)和执行(x)的权限 chmod go-rwx directory1 删除群组(g)与其他人(o)对目录的读写执行权限 chown user1 file1 改变一个文件的所有人属性 chown -R user1 directory1 改变一个目录的所有人属性并同时改变改目录下所有文件的属性 chgrp group1 file1 改变文件的群组 chown user1:group1 file1 改变一个文件的所有人和群组属性 find / -perm -u+s 罗列一个系统中所有使用了SUID控制的文件 chmod u+s /bin/file1 设置一个二进制文件的 SUID 位 - 运行该文件的用户也被赋予和所有者同样的权限 chmod u-s /bin/file1 禁用一个二进制文件的 SUID位 chmod g+s /home/public 设置一个目录的SGID 位 - 类似SUID ，不过这是针对目录的 chmod g-s /home/public 禁用一个目录的 SGID 位 chmod o+t /home/public 设置一个文件的 STIKY 位 - 只允许合法所有人删除文件 chmod o-t /home/public 禁用一个目录的 STIKY 位 文件的特殊属性 - 使用 “+” 设置权限，使用 “-“ 用于取消12345678chattr +a file1 只允许以追加方式读写文件 chattr +c file1 允许这个文件能被内核自动压缩/解压 chattr +d file1 在进行文件系统备份时，dump程序将忽略这个文件 chattr +i file1 设置成不可变的文件，不能被删除、修改、重命名或者链接 chattr +s file1 允许一个文件被安全地删除 chattr +S file1 一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘 chattr +u file1 若文件被删除，系统会允许你在以后恢复这个被删除的文件 lsattr 显示特殊的属性 打包和压缩文件123456789101112131415161718192021bunzip2 file1.bz2 解压一个叫做 &apos;file1.bz2&apos;的文件 bzip2 file1 压缩一个叫做 &apos;file1&apos; 的文件 gunzip file1.gz 解压一个叫做 &apos;file1.gz&apos;的文件 gzip file1 压缩一个叫做 &apos;file1&apos;的文件 gzip -9 file1 最大程度压缩 rar a file1.rar test_file 创建一个叫做 &apos;file1.rar&apos; 的包 rar a file1.rar file1 file2 dir1 同时压缩 &apos;file1&apos;, &apos;file2&apos; 以及目录 &apos;dir1&apos; rar x file1.rar 解压rar包 unrar x file1.rar 解压rar包 tar -cvf archive.tar file1 创建一个非压缩的 tarball tar -cvf archive.tar file1 file2 dir1 创建一个包含了 &apos;file1&apos;, &apos;file2&apos; 以及 &apos;dir1&apos;的档案文件 tar -tf archive.tar 显示一个包中的内容 tar -xvf archive.tar 释放一个包 tar -xvf archive.tar -C /tmp 将压缩包释放到 /tmp目录下 tar -cvfj archive.tar.bz2 dir1 创建一个bzip2格式的压缩包 tar -jxvf archive.tar.bz2 解压一个bzip2格式的压缩包 tar -cvfz archive.tar.gz dir1 创建一个gzip格式的压缩包 tar -zxvf archive.tar.gz 解压一个gzip格式的压缩包 zip file1.zip file1 创建一个zip格式的压缩包 zip -r file1.zip file1 file2 dir1 将几个文件和目录同时压缩成一个zip格式的压缩包 unzip file1.zip 解压一个zip格式压缩包 RPM 包 - （Fedora, Redhat及类似系统）1234567891011121314151617181920212223242526rpm -ivh package.rpm 安装一个rpm包 rpm -ivh --nodeeps package.rpm 安装一个rpm包而忽略依赖关系警告 rpm -U package.rpm 更新一个rpm包但不改变其配置文件 rpm -F package.rpm 更新一个确定已经安装的rpm包 rpm -e package_name.rpm 删除一个rpm包 rpm -qa 显示系统中所有已经安装的rpm包 rpm -qa | grep httpd 显示所有名称中包含 &quot;httpd&quot; 字样的rpm包 rpm -qi package_name 获取一个已安装包的特殊信息 rpm -qg &quot;System Environment/Daemons&quot; 显示一个组件的rpm包 rpm -ql package_name 显示一个已经安装的rpm包提供的文件列表 rpm -qc package_name 显示一个已经安装的rpm包提供的配置文件列表 rpm -q package_name --whatrequires 显示与一个rpm包存在依赖关系的列表 rpm -q package_name --whatprovides 显示一个rpm包所占的体积 rpm -q package_name --scripts 显示在安装/删除期间所执行的脚本l rpm -q package_name --changelog 显示一个rpm包的修改历史 rpm -qf /etc/httpd/conf/httpd.conf 确认所给的文件由哪个rpm包所提供 rpm -qp package.rpm -l 显示由一个尚未安装的rpm包提供的文件列表 rpm --import /media/cdrom/RPM-GPG-KEY 导入公钥数字证书 rpm --checksig package.rpm 确认一个rpm包的完整性 rpm -qa gpg-pubkey 确认已安装的所有rpm包的完整性 rpm -V package_name 检查文件尺寸、 许可、类型、所有者、群组、MD5检查以及最后修改时间 rpm -Va 检查系统中所有已安装的rpm包- 小心使用 rpm -Vp package.rpm 确认一个rpm包还未安装 rpm2cpio package.rpm | cpio --extract --make-directories *bin* 从一个rpm包运行可执行文件 rpm -ivh /usr/src/redhat/RPMS/`arch`/package.rpm 从一个rpm源码安装一个构建好的包 rpmbuild --rebuild package_name.src.rpm 从一个rpm源码构建一个 rpm 包 YUM 软件包升级器 - （Fedora, RedHat及类似系统）12345678910yum install package_name 下载并安装一个rpm包 yum localinstall package_name.rpm 将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系 yum update package_name.rpm 更新当前系统中所有安装的rpm包 yum update package_name 更新一个rpm包 yum remove package_name 删除一个rpm包 yum list 列出当前系统中安装的所有包 yum search package_name 在rpm仓库中搜寻软件包 yum clean packages 清理rpm缓存删除下载的包 yum clean headers 删除所有头文件 yum clean all 删除所有缓存的包和头文件 DEB 包 (Debian, Ubuntu 以及类似系统)12345678dpkg -i package.deb 安装/更新一个 deb 包 dpkg -r package_name 从系统删除一个 deb 包 dpkg -l 显示系统中所有已经安装的 deb 包 dpkg -l | grep httpd 显示所有名称中包含 &quot;httpd&quot; 字样的deb包 dpkg -s package_name 获得已经安装在系统中一个特殊包的信息 dpkg -L package_name 显示系统中已经安装的一个deb包所提供的文件列表 dpkg --contents package.deb 显示尚未安装的一个包所提供的文件列表 dpkg -S /bin/ping 确认所给的文件由哪个deb包提供 APT 软件工具 (Debian, Ubuntu 以及类似系统)12345678apt-get install package_name 安装/更新一个 deb 包 apt-cdrom install package_name 从光盘安装/更新一个 deb 包 apt-get update 升级列表中的软件包 apt-get upgrade 升级所有已安装的软件 apt-get remove package_name 从系统删除一个deb包 apt-get check 确认依赖的软件仓库正确 apt-get clean 从下载的软件包中清理缓存 apt-cache search searched-package 返回包含所要搜索字符串的软件包名称 查看文件内容1234567cat file1 从第一个字节开始正向查看文件的内容 tac file1 从最后一行开始反向查看一个文件的内容 more file1 查看一个长文件的内容 less file1 类似于 &apos;more&apos; 命令，但是它允许在文件中和正向操作一样的反向操作 head -2 file1 查看一个文件的前两行 tail -2 file1 查看一个文件的最后两行 tail -f /var/log/messages 实时查看被添加到一个文件中的内容 文本处理12345678910111213141516171819202122232425262728293031cat file1 file2 ... | command &lt;&gt; file1_in.txt_or_file1_out.txt general syntax for text manipulation using PIPE, STDIN and STDOUT cat file1 | command( sed, grep, awk, grep, etc...) &gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个新文件中 cat file1 | command( sed, grep, awk, grep, etc...) &gt;&gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个已有的文件中 grep Aug /var/log/messages 在文件 &apos;/var/log/messages&apos;中查找关键词&quot;Aug&quot; grep ^Aug /var/log/messages 在文件 &apos;/var/log/messages&apos;中查找以&quot;Aug&quot;开始的词汇 grep [0-9] /var/log/messages 选择 &apos;/var/log/messages&apos; 文件中所有包含数字的行 grep Aug -R /var/log/* 在目录 &apos;/var/log&apos; 及随后的目录中搜索字符串&quot;Aug&quot; sed &apos;s/stringa1/stringa2/g&apos; example.txt 将example.txt文件中的 &quot;string1&quot; 替换成 &quot;string2&quot; sed &apos;/^$/d&apos; example.txt 从example.txt文件中删除所有空白行 sed &apos;/ *#/d; /^$/d&apos; example.txt 从example.txt文件中删除所有注释和空白行 echo &apos;esempio&apos; | tr &apos;[:lower:]&apos; &apos;[:upper:]&apos; 合并上下单元格内容 sed -e &apos;1d&apos; result.txt 从文件example.txt 中排除第一行 sed -n &apos;/stringa1/p&apos; 查看只包含词汇 &quot;string1&quot;的行 sed -e &apos;s/ *$//&apos; example.txt 删除每一行最后的空白字符 sed -e &apos;s/stringa1//g&apos; example.txt 从文档中只删除词汇 &quot;string1&quot; 并保留剩余全部 sed -n &apos;1,5p;5q&apos; example.txt 查看从第一行到第5行内容 sed -n &apos;5p;5q&apos; example.txt 查看第5行 sed -e &apos;s/00*/0/g&apos; example.txt 用单个零替换多个零 cat -n file1 标示文件的行数 cat example.txt | awk &apos;NR%2==1&apos; 删除example.txt文件中的所有偶数行 echo a b c | awk &apos;&#123;print $1&#125;&apos; 查看一行第一栏 echo a b c | awk &apos;&#123;print $1,$3&#125;&apos; 查看一行的第一和第三栏 paste file1 file2 合并两个文件或两栏的内容 paste -d &apos;+&apos; file1 file2 合并两个文件或两栏的内容，中间用&quot;+&quot;区分 sort file1 file2 排序两个文件的内容 sort file1 file2 | uniq 取出两个文件的并集(重复的行只保留一份) sort file1 file2 | uniq -u 删除交集，留下其他的行 sort file1 file2 | uniq -d 取出两个文件的交集(只留下同时存在于两个文件中的文件) comm -1 file1 file2 比较两个文件的内容只删除 &apos;file1&apos; 所包含的内容 comm -2 file1 file2 比较两个文件的内容只删除 &apos;file2&apos; 所包含的内容 comm -3 file1 file2 比较两个文件的内容只删除两个文件共有的部分 字符设置和文件格式转换1234dos2unix filedos.txt fileunix.txt 将一个文本文件的格式从MSDOS转换成UNIX unix2dos fileunix.txt filedos.txt 将一个文本文件的格式从UNIX转换成MSDOS recode ..HTML &lt; page.txt &gt; page.html 将一个文本文件转换成html recode -l | more 显示所有允许的转换格式 文件系统分析123456789badblocks -v /dev/hda1 检查磁盘hda1上的坏磁块 fsck /dev/hda1 修复/检查hda1磁盘上linux文件系统的完整性 fsck.ext2 /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性 e2fsck /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性 e2fsck -j /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性 fsck.ext3 /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性 fsck.vfat /dev/hda1 修复/检查hda1磁盘上fat文件系统的完整性 fsck.msdos /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性 dosfsck /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性 初始化一个文件系统123456mkfs /dev/hda1 在hda1分区创建一个文件系统 mke2fs /dev/hda1 在hda1分区创建一个linux ext2的文件系统 mke2fs -j /dev/hda1 在hda1分区创建一个linux ext3(日志型)的文件系统 mkfs -t vfat 32 -F /dev/hda1 创建一个 FAT32 文件系统 fdformat -n /dev/fd0 格式化一个软盘 mkswap /dev/hda3 创建一个swap文件系统 SWAP文件系统123mkswap /dev/hda3 创建一个swap文件系统 swapon /dev/hda3 启用一个新的swap文件系统 swapon /dev/hda2 /dev/hdb3 启用两个swap分区 备份1234567891011121314151617dump -0aj -f /tmp/home0.bak /home 制作一个 &apos;/home&apos; 目录的完整备份 dump -1aj -f /tmp/home0.bak /home 制作一个 &apos;/home&apos; 目录的交互式备份 restore -if /tmp/home0.bak 还原一个交互式备份 rsync -rogpav --delete /home /tmp 同步两边的目录 rsync -rogpav -e ssh --delete /home ip_address:/tmp 通过SSH通道rsync rsync -az -e ssh --delete ip_addr:/home/public /home/local 通过ssh和压缩将一个远程目录同步到本地目录 rsync -az -e ssh --delete /home/local ip_addr:/home/public 通过ssh和压缩将本地目录同步到远程目录 dd bs=1M if=/dev/hda | gzip | ssh user@ip_addr &apos;dd of=hda.gz&apos; 通过ssh在远程主机上执行一次备份本地磁盘的操作 dd if=/dev/sda of=/tmp/file1 备份磁盘内容到一个文件 tar -Puf backup.tar /home/user 执行一次对 &apos;/home/user&apos; 目录的交互式备份操作 ( cd /tmp/local/ &amp;&amp; tar c . ) | ssh -C user@ip_addr &apos;cd /home/share/ &amp;&amp; tar x -p&apos; 通过ssh在远程目录中复制一个目录内容 ( tar c /home ) | ssh -C user@ip_addr &apos;cd /home/backup-home &amp;&amp; tar x -p&apos; 通过ssh在远程目录中复制一个本地目录 tar cf - . | (cd /tmp/backup ; tar xf - ) 本地将一个目录复制到另一个地方，保留原有权限及链接 find /home/user1 -name &apos;*.txt&apos; | xargs cp -av --target-directory=/home/backup/ --parents 从一个目录查找并复制所有以 &apos;.txt&apos; 结尾的文件到另一个目录 find /var/log -name &apos;*.log&apos; | tar cv --files-from=- | bzip2 &gt; log.tar.bz2 查找所有以 &apos;.log&apos; 结尾的文件并做成一个bzip包 dd if=/dev/hda of=/dev/fd0 bs=512 count=1 做一个将 MBR (Master Boot Record)内容复制到软盘的动作 dd if=/dev/fd0 of=/dev/hda bs=512 count=1 从已经保存到软盘的备份中恢复MBR内容 光盘1234567891011cdrecord -v gracetime=2 dev=/dev/cdrom -eject blank=fast -force 清空一个可复写的光盘内容 mkisofs /dev/cdrom &gt; cd.iso 在磁盘上创建一个光盘的iso镜像文件 mkisofs /dev/cdrom | gzip &gt; cd_iso.gz 在磁盘上创建一个压缩了的光盘iso镜像文件 mkisofs -J -allow-leading-dots -R -V &quot;Label CD&quot; -iso-level 4 -o ./cd.iso data_cd 创建一个目录的iso镜像文件 cdrecord -v dev=/dev/cdrom cd.iso 刻录一个ISO镜像文件 gzip -dc cd_iso.gz | cdrecord dev=/dev/cdrom - 刻录一个压缩了的ISO镜像文件 mount -o loop cd.iso /mnt/iso 挂载一个ISO镜像文件 cd-paranoia -B 从一个CD光盘转录音轨到 wav 文件中 cd-paranoia -- &quot;-3&quot; 从一个CD光盘转录音轨到 wav 文件中（参数-3） cdrecord --scanbus 扫描总线以识别scsi通道 dd if=/dev/hdc | md5sum 校验一个设备的md5sum编码，例如一张 CD 网络 - （以太网和WIFI无线）123456789101112131415161718192021222324252627ifconfig eth0 显示一个以太网卡的配置 ifup eth0 启用一个 &apos;eth0&apos; 网络设备 ifdown eth0 禁用一个 &apos;eth0&apos; 网络设备 ifconfig eth0 192.168.1.1 netmask 255.255.255.0 控制IP地址 ifconfig eth0 promisc 设置 &apos;eth0&apos; 成混杂模式以嗅探数据包 (sniffing) dhclient eth0 以dhcp模式启用 &apos;eth0&apos; route -n 显示路由表route add -net 0/0 gw IP_Gateway 配置默认网关route add -net 192.168.0.0 netmask 255.255.0.0 gw 192.168.1.1 配置静态路由以到达网络&apos;192.168.0.0/16&apos;route del 0/0 gw IP_gateway 删除静态路由echo &quot;1&quot; &gt; /proc/sys/net/ipv4/ip_forward 激活IP路由hostname show hostname of system//以下懒得翻译了host www.example.com lookup hostname to resolve name to ip address and viceversa(1) nslookup www.example.com lookup hostname to resolve name to ip address and viceversa(2) ip link show show link status of all interfaces mii-tool eth0 show link status of &apos;eth0&apos; ethtool eth0 show statistics of network card &apos;eth0&apos; netstat -tup show all active network connections and their PID netstat -tupl show all network services listening on the system and their PID tcpdump tcp port 80 show all HTTP traffic iwlist scan show wireless networks iwconfig eth1 show configuration of a wireless network card hostname show hostname host www.example.com lookup hostname to resolve name to ip address and viceversa nslookup www.example.com lookup hostname to resolve name to ip address and viceversa whois www.example.com lookup on Whois database","categories":[{"name":"Linux","slug":"Linux","permalink":"http://excu4fun.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://excu4fun.com/tags/Linux/"}]},{"title":"经典排序算法（持续更新）","slug":"sorting_Algorithm","date":"2018-11-16T16:00:00.000Z","updated":"2018-11-17T09:31:52.789Z","comments":true,"path":"2018/11/17/sorting_Algorithm/","link":"","permalink":"http://excu4fun.com/2018/11/17/sorting_Algorithm/","excerpt":"","text":"经典排序算法特征总结： 排序算法 时间复杂度平均情况 最坏情况 最好情况 空间复杂度 稳定性 复杂性 直接插入排序 O(n²) O(n²) O(n) O(1) 稳定 简单 希尔排序 O(nlog2n) O(nlog2n) O(1) 不稳定 较复杂 冒泡排序 O(n²) O(n²) O(n) O(1) 稳定) 简单 快速排序 O(nlog2n) O(n²) O(nlog2n) O(nlog2n) 不稳定 较复杂 直接选择排序 O(n²) O(n²) O(n²) O(1) 不稳定 简单 堆排序 O(nlog2n) O(nlog2n) O(nlog2n) O(1) 不稳定 较复杂 归并排序 O(nlog2n) O(nlog2n) O(nlog2n) O(n) 稳定 较复杂 基数排序 O(d(n+r)) O(d(n+r)) O(d(n+r)) O(n+r) 稳定 较复杂 冒泡排序&emsp;&emsp;冒泡排序是最简单的排序之一了，其大体思想就是通过与相邻元素的比较和交换来把小的数交换到最前面。这个过程类似于水泡向上升一样，因此而得名。冒泡排序的时间复杂度为O(n^2)。 java实现代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** *@Description:&lt;p&gt;冒泡排序算法实现&lt;/p&gt; *@author Eric Zhang *@time 2018-11-17 下午13：34：19 */public class BubbleSort &#123; public static void bubbleSort(int[] arr) &#123; if(arr == null || arr.length == 0) return ; for(int i=0; i&lt;arr.length-1; i++) &#123; for(int j=arr.length-1; j&gt;i; j--) &#123; if(arr[j] &lt; arr[j-1]) &#123; swap(arr, j-1, j); &#125; &#125; &#125; &#125; public static void swap(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; public static void main(String[] args) &#123; int size = 10; //数组大小 int [] arrayRefVar = new int[size]; //初始化 arrayRefVar[0] = 5; arrayRefVar[1] = 4; arrayRefVar[2] = 3; arrayRefVar[3] = 13; arrayRefVar[4] = 4; arrayRefVar[5] = 34; arrayRefVar[6] = 34; arrayRefVar[7] = 45; arrayRefVar[8] = 99; arrayRefVar[9] = 1; //排序前 for (int i = 0; i &lt; arrayRefVar.length; i++) &#123; System.out.println(arrayRefVar[i] + &quot; &quot;); &#125; System.out.println(&quot;排序后结果：&quot;); bubbleSort(arrayRefVar); //排序后 for (int i = 0; i &lt; arrayRefVar.length; i++) &#123; System.out.println(arrayRefVar[i] + &quot; &quot;); &#125; &#125;&#125; 输出结果如下：1234567891011121314151617181920215 4 3 13 4 34 34 45 99 1 排序后结果：1 3 4 4 5 13 34 34 45 99 C++实现代码如下：12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;using namespace std;template&lt;typename T&gt;//整数或浮点数皆可使用void bubble_sort(T arr[], int len)&#123; int i, j; T temp; for (i = 0; i &lt; len - 1; i++) for (j = 0; j &lt; len - 1 - i; j++) if (arr[j] &gt; arr[j + 1]) &#123; temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125;&#125;int main()&#123; int arr[] = &#123; 61, 17, 29, 22, 34, 60, 72, 21, 50, 1, 62 &#125;; int len = (int) sizeof(arr) / sizeof(*arr); bubble_sort(arr, len); for (int i = 0; i &lt; len; i++) cout &lt;&lt; arr[i] &lt;&lt; &apos; &apos;; cout &lt;&lt; endl; float arrf[] = &#123; 17.5, 19.1, 0.6, 1.9, 10.5, 12.4, 3.8, 19.7, 1.5, 25.4, 28.6, 4.4, 23.8, 5.4 &#125;; len = (int) sizeof(arrf) / sizeof(*arrf); bubble_sort(arrf, len); for (int i = 0; i &lt; len; i++) cout &lt;&lt; arrf[i] &lt;&lt; &apos; &apos;; return 0;&#125; 选择排序&emsp;&emsp;选择排序的思想其实和冒泡排序有点类似，都是在一次排序后把最小的元素放到最前面。但是过程不同，冒泡排序是通过相邻的比较和交换。而选择排序是通过对整体的选择。选择排序的时间复杂度为O(n^2)java实现代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** *@Description:&lt;p&gt;选择排序算法实现&lt;/p&gt; *@author Eric Zhang *@time 2018-11-17 下午13：52: 11 */public class SelectSort &#123; public static void selectSort(int[] arr) &#123; if(arr == null || arr.length == 0) return ; int minIndex = 0; for(int i=0; i&lt;arr.length-1; i++) &#123; //只需要比较n-1次 minIndex = i; for(int j=i+1; j&lt;arr.length; j++) &#123; //从i+1开始比较，因为minIndex默认为i了，i就没必要比了。 if(arr[j] &lt; arr[minIndex]) &#123; minIndex = j; &#125; &#125; if(minIndex != i) &#123; //如果minIndex不为i，说明找到了更小的值，交换之。 swap(arr, i, minIndex); &#125; &#125; &#125; public static void swap(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; public static void main(String[] args) &#123; int size = 10; //数组大小 int [] arrayRefVar = new int[size]; //初始化 arrayRefVar[0] = 56; arrayRefVar[1] = 3; arrayRefVar[2] = 1; arrayRefVar[3] = 28; arrayRefVar[4] = 97; arrayRefVar[5] = 46; arrayRefVar[6] = 35; arrayRefVar[7] = 11; arrayRefVar[8] = 74; arrayRefVar[9] = 151; //排序前 for (int i = 0; i &lt; arrayRefVar.length; i++) &#123; System.out.println(arrayRefVar[i] + &quot; &quot;); &#125; System.out.println(&quot;排序后结果：&quot;); selectSort(arrayRefVar); //排序后 for (int i = 0; i &lt; arrayRefVar.length; i++) &#123; System.out.println(arrayRefVar[i] + &quot; &quot;); &#125; &#125;&#125; 输出结果如下：12345678910111213141516171819202156 3 1 28 97 46 35 11 74 151 排序后结果：1 3 11 28 35 46 56 74 97 151 C++实现代码如下：123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#include&lt;time.h&gt;#include&lt;iomanip&gt;using namespace std;const int N=10;int main()&#123; int a[N],i,j,temp,b; srand(time(NULL)); for(i=0;i&lt;N;i++) a[i]=rand()%100; for(i=0;i&lt;N;i++) cout&lt;&lt;setw(3)&lt;&lt;a[i]; cout&lt;&lt;endl; for(i=0;i&lt;N-1;i++)&#123; temp=i; for(j=i+1;j&lt;N;j++) &#123; if(a[temp]&gt;a[j]) temp=j; &#125; if(i!=temp) &#123; b=a[temp]; a[temp]=a[i]; a[i]=b;&#125; &#125; for(i=0;i&lt;N;i++) cout&lt;&lt;setw(3)&lt;&lt;a[i]; cout&lt;&lt;endl;&#125; 插入排序&emsp;&emsp;插入排序不是通过交换位置而是通过比较找到合适的位置插入元素来达到排序的目的的。相信大家都有过打扑克牌的经历，特别是牌数较大的。在分牌时可能要整理自己的牌，牌多的时候怎么整理呢？就是拿到一张牌，找到一个合适的位置插入。插入排序的原理其实就是这样。简单插入排序的时间复杂度也是O(n²)。java实现代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** *@Description:&lt;p&gt;简单插入排序算法实现&lt;/p&gt; *@author Eric Zhang *@time 2018-11-17 下午14：06：43 */public class InsertSort &#123; public static void insertSort(int[] arr) &#123; if(arr == null || arr.length == 0) return ; for(int i=1; i&lt;arr.length; i++) &#123; //假设第一个数位置时正确的；要往后移，必须要假设第一个。 int j = i; int target = arr[i]; //待插入的 //后移 while(j &gt; 0 &amp;&amp; target &lt; arr[j-1]) &#123; arr[j] = arr[j-1]; j --; &#125; //插入 arr[j] = target; &#125; &#125; public static void main(String[] args) &#123; int size = 10; //数组大小 int [] arrayRefVar = new int[size]; //初始化 arrayRefVar[0] = 97; arrayRefVar[1] = 26; arrayRefVar[2] = 55; arrayRefVar[3] = 63; arrayRefVar[4] = 1; arrayRefVar[5] = 42; arrayRefVar[6] = 7; arrayRefVar[7] = 98; arrayRefVar[8] = 66; arrayRefVar[9] = 21; //排序前 for (int i = 0; i &lt; arrayRefVar.length; i++) &#123; System.out.println(arrayRefVar[i] + &quot; &quot;); &#125; System.out.println(&quot;排序后结果：&quot;); insertSort(arrayRefVar); //排序后 for (int i = 0; i &lt; arrayRefVar.length; i++) &#123; System.out.println(arrayRefVar[i] + &quot; &quot;); &#125; &#125;&#125; 输出结果如下：12345678910111213141516171819202197 26 55 63 1 42 7 98 66 21 排序后结果：1 7 21 26 42 55 63 66 97 98 C++实现代码如下：123456789101112131415161718192021#include&lt;iostream&gt;using namespace std;int main()&#123; int a[]=&#123;98,76,109,34,67,190,80,12,14,89,1&#125;; int k=sizeof(a)/sizeof(a[0]); int j; for(int i=1;i&lt;k;i++)&#123;//循环从第2个元素开始 if(a[i]&lt;a[i-1])&#123; int temp=a[i]; for(j=i-1;j&gt;=0 &amp;&amp; a[j]&gt;temp;j--) &#123; a[j+1]=a[j]; &#125; a[j+1]=temp;//此处就是a[j+1]=temp; &#125; &#125; for(int f=0;f&lt;k;f++)&#123; cout&lt;&lt;a[f]&lt;&lt;&quot; &quot;; &#125; return 0;&#125; 快速排序&emsp;&emsp;在实际应用当中快速排序是表现最好的排序算法。其思想是来自冒泡排序，冒泡排序是通过相邻元素的比较和交换把最小的冒泡到最顶端，而快速排序是比较和交换小数和大数，这样一来不仅把小数冒泡到上面同时也把大数沉到下面。快速排序是不稳定的，其时间平均时间复杂度是O(nlgn)。java实现代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041/** *@Description:&lt;p&gt;快速排序算法实现&lt;/p&gt; *@author Eric Zhang *@time 2018-11-17 下午14：37：03 */public class QuickSort &#123; public static int partition(int[] arr, int left, int right) &#123; int pivotKey = arr[left]; int pivotPointer = left; while(left &lt; right) &#123; while(left &lt; right &amp;&amp; arr[right] &gt;= pivotKey) right --; while(left &lt; right &amp;&amp; arr[left] &lt;= pivotKey) left ++; swap(arr, left, right); //把大的交换到右边，把小的交换到左边。 &#125; swap(arr, pivotPointer, left); //最后把pivot交换到中间 return left; &#125; public static void quickSort(int[] arr, int left, int right) &#123; if(left &gt;= right) return ; int pivotPos = partition(arr, left, right); quickSort(arr, left, pivotPos-1); quickSort(arr, pivotPos+1, right); &#125; public static void sort(int[] arr) &#123; if(arr == null || arr.length == 0) return ; quickSort(arr, 0, arr.length-1); &#125; public static void swap(int[] arr, int left, int right) &#123; int temp = arr[left]; arr[left] = arr[right]; arr[right] = temp; &#125; &#125; 优化版java实现代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** *@Description:&lt;p&gt;快速排序算法实现&lt;/p&gt; *@author Eric Zhang *@time 2018-11-17 下午14：58：23 */public class QuickSort &#123; /** * 划分 * @param arr * @param left * @param right * @return */ public static int partition(int[] arr, int left, int right) &#123; int pivotKey = arr[left]; while(left &lt; right) &#123; while(left &lt; right &amp;&amp; arr[right] &gt;= pivotKey) right --; arr[left] = arr[right]; //把小的移动到左边 while(left &lt; right &amp;&amp; arr[left] &lt;= pivotKey) left ++; arr[right] = arr[left]; //把大的移动到右边 &#125; arr[left] = pivotKey; //最后把pivot赋值到中间 return left; &#125; /** * 递归划分子序列 * @param arr * @param left * @param right */ public static void quickSort(int[] arr, int left, int right) &#123; if(left &gt;= right) return ; int pivotPos = partition(arr, left, right); quickSort(arr, left, pivotPos-1); quickSort(arr, pivotPos+1, right); &#125; public static void sort(int[] arr) &#123; if(arr == null || arr.length == 0) return ; quickSort(arr, 0, arr.length-1); &#125; &#125; C++实现代码如下：12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;using namespace std;void QucikSort(int a[], int left, int right)&#123; if(left &gt;= right)&#123; return; &#125; int first = left; int last = right; int key = a[first]; while(first &lt; last)&#123; while(first &lt; last &amp;&amp; a[last] &gt;= key) &#123; --last; &#125; a[first] = a[last]; while(first &lt; last &amp;&amp; a[first] &lt;= key) &#123; ++first; &#125; a[last] = a[first]; &#125; a[first] = key; QuickSort(a, left, first-1); QuickSort(a, first+1, right);&#125;int main()&#123; int a[] = &#123;11, 7, 99, 44, 121, 54, 66, 77, 22, 31&#125;; QuickSort(a, 0, sizeof(a) / sizeof(a[0]) - 1); for(int i = 0; i &lt; sizeof(a) / sizeof(a[0]); i++)&#123; cout &lt;&lt; a[i] &lt;&lt; &quot;&quot;; &#125; return 0;&#125; 总结快速排序的思想：冒泡+二分+递归分治 堆排序&emsp;&emsp;堆排序是借助堆来实现的选择排序，思想同简单的选择排序，以下以大顶堆为例。注意：如果想升序排序就使用大顶堆，反之使用小顶堆。原因是堆顶元素需要交换到序列尾部。&emsp;&emsp;首先，实现堆排序需要解决两个问题：&emsp;&emsp;1. 如何由一个无序序列键成一个堆？&emsp;&emsp;2. 如何在输出堆顶元素之后，调整剩余元素成为一个新的堆？&emsp;&emsp;第一个问题，可以直接使用线性数组来表示一个堆，由初始的无序序列建成一个堆就需要自底向上从第一个非叶元素开始挨个调整成一个堆。&emsp;&emsp;第二个问题，怎么调整成堆？首先是将堆顶元素和最后一个元素交换。然后比较当前堆顶元素的左右孩子节点，因为除了当前的堆顶元素，左右孩子堆均满足条件，这时需要选择当前堆顶元素与左右孩子节点的较大者（大顶堆）交换，直至叶子节点。我们称这个自堆顶自叶子的调整成为筛选。&emsp;&emsp;从一个无序序列建堆的过程就是一个反复筛选的过程。若将此序列看成是一个完全二叉树，则最后一个非终端节点是n/2取底个元素，由此筛选即可。举个栗子：49,38,65,97,76,13,27,49序列的堆排序建初始堆和调整的过程如下： java实现代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** *@Description:&lt;p&gt;堆排序算法实现&lt;/p&gt; *@author Eric Zhang *@time 2018-11-17 下午15：47：09 */public class HeapSort &#123; /** * 堆筛选，除了start之外，start~end均满足大顶堆的定义。 * 调整之后start~end称为一个大顶堆。 * @param arr 待调整数组 * @param start 起始指针 * @param end 结束指针 */ public static void heapAdjust(int[] arr, int start, int end) &#123; int temp = arr[start]; for(int i=2*start+1; i&lt;=end; i*=2) &#123; //左右孩子的节点分别为2*i+1,2*i+2 //选择出左右孩子较小的下标 if(i &lt; end &amp;&amp; arr[i] &lt; arr[i+1]) &#123; i ++; &#125; if(temp &gt;= arr[i]) &#123; break; //已经为大顶堆，=保持稳定性。 &#125; arr[start] = arr[i]; //将子节点上移 start = i; //下一轮筛选 &#125; arr[start] = temp; //插入正确的位置 &#125; public static void heapSort(int[] arr) &#123; if(arr == null || arr.length == 0) return ; //建立大顶堆 for(int i=arr.length/2; i&gt;=0; i--) &#123; heapAdjust(arr, i, arr.length-1); &#125; for(int i=arr.length-1; i&gt;=0; i--) &#123; swap(arr, 0, i); heapAdjust(arr, 0, i-1); &#125; &#125; public static void swap(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125;&#125; C++实现代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std; void max_heapify(int arr[], int start, int end) &#123; //建立父节点指标和子节点指标 int dad = start; int son = dad * 2 + 1; while (son &lt;= end) &#123; //若子节点指标在范围内才做比较 if (son + 1 &lt;= end &amp;&amp; arr[son] &lt; arr[son + 1]) //先比较两个子节点大小，选择最大的 son++; if (arr[dad] &gt; arr[son]) //如果父节点大於子节点代表调整完毕，直接跳出函数 return; else &#123; //否则交换父子内容再继续子节点和孙节点比较 swap(arr[dad], arr[son]); dad = son; son = dad * 2 + 1; &#125; &#125;&#125;void heap_sort(int arr[], int len) &#123; //初始化，i从最後一个父节点开始调整 for (int i = len / 2 - 1; i &gt;= 0; i--) max_heapify(arr, i, len - 1); //先将第一个元素和已经排好的元素前一位做交换，再从新调整(刚调整的元素之前的元素)，直到排序完毕 for (int i = len - 1; i &gt; 0; i--) &#123; swap(arr[0], arr[i]); max_heapify(arr, 0, i - 1); &#125;&#125; int main() &#123; int arr[] = &#123; 3, 5, 3, 0, 8, 6, 1, 5, 8, 6, 2, 4, 9, 4, 7, 0, 1, 8, 9, 7, 3, 1, 2, 5, 9, 7, 4, 0, 2, 6 &#125;; int len = (int) sizeof(arr) / sizeof(*arr); heap_sort(arr, len); for (int i = 0; i &lt; len; i++) cout &lt;&lt; arr[i] &lt;&lt; &apos; &apos;; cout &lt;&lt; endl; return 0;&#125; 希尔排序&emsp;&emsp;希尔排序是插入排序的一种高效率的实现，也叫缩小增量排序。简单的插入排序中，如果待排序列是正序时，时间复杂度是O(n)，如果序列是基本有序的，使用直接插入排序效率就非常高。希尔排序就利用了这个特点。基本思想是：先将整个待排记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录基本有序时再对全体记录进行一次直接插入排序。&emsp;&emsp;从上述排序过程可见，希尔排序的特点是，子序列的构成不是简单的逐段分割，而是将某个相隔某个增量的记录组成一个子序列。如上面的例子，第一堂排序时的增量为5，第二趟排序的增量为3。由于前两趟的插入排序中记录的关键字是和同一子序列中的前一个记录的关键字进行比较，因此关键字较小的记录就不是一步一步地向前挪动，而是跳跃式地往前移，从而使得进行最后一趟排序时，整个序列已经做到基本有序，只要作记录的少量比较和移动即可。因此希尔排序的效率要比直接插入排序高。&emsp;&emsp;希尔排序的分析是复杂的，时间复杂度是所取增量的函数，这涉及一些数学上的难题。但是在大量实验的基础上推出当n在某个范围内时，时间复杂度可以达到O(n^1.3)。 java实现代码如下： 1234567891011121314151617181920212223242526272829303132333435363738/** *@Description:&lt;p&gt;希尔排序算法实现&lt;/p&gt; *@author Eric Zhang *@time 2018-11-17 下午16：31：41 */public class ShellSort &#123; /** * 希尔排序的一趟插入 * @param arr 待排数组 * @param d 增量 */ public static void shellInsert(int[] arr, int d) &#123; for(int i=d; i&lt;arr.length; i++) &#123; int j = i - d; int temp = arr[i]; //记录要插入的数据 while (j&gt;=0 &amp;&amp; arr[j]&gt;temp) &#123; //从后向前，找到比其小的数的位置 arr[j+d] = arr[j]; //向后挪动 j -= d; &#125; if (j != i - d) //存在比其小的数 arr[j+d] = temp; &#125; &#125; public static void shellSort(int[] arr) &#123; if(arr == null || arr.length == 0) return ; int d = arr.length / 2; while(d &gt;= 1) &#123; shellInsert(arr, d); d /= 2; &#125; &#125;&#125; C++实现代码如下：1234567891011121314151617void swapInt(int * a,int*b)&#123; int c=*a; *a=*b; *b=c;&#125;void shell(int*data,unsigned int len)&#123; if(len&lt;=1||data==NULL) return; for(int div=len/2;div&gt;=1;div=div/2)&#123;//定增量div，并不断减小 for(int i=0;i&lt;div;++i)&#123;//分组成div组 for(int j=i;j&lt;len-div;j+=div)//对每组进行插入排序 for(int k=j;k&lt;len;k+=div) if(data[j]&gt;data[k]) swapInt(data+j,data+k);//交换两个数的值 &#125; &#125;&#125; 归并排序&emsp;&emsp;归并排序是另一种不同的排序方法，因为归并排序使用了递归分治的思想，所以理解起来比较容易。其基本思想是，先递归划分子问题，然后合并结果。把待排序列看成由两个有序的子序列，然后合并两个子序列，然后把子序列看成由两个有序序列。。。。。倒着来看，其实就是先两两合并，然后四四合并。。。最终形成有序序列。空间复杂度为O(n)，时间复杂度为O(nlogn)。 java实现代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** *@Description:&lt;p&gt;归并排序算法实现&lt;/p&gt; *@author Eric Zhang *@time 2018-11-17 下午16：55：52 */public class MergeSort &#123; public static void mergeSort(int[] arr) &#123; mSort(arr, 0, arr.length-1); &#125; /** * 递归分治 * @param arr 待排数组 * @param left 左指针 * @param right 右指针 */ public static void mSort(int[] arr, int left, int right) &#123; if(left &gt;= right) return ; int mid = (left + right) / 2; mSort(arr, left, mid); //递归排序左边 mSort(arr, mid+1, right); //递归排序右边 merge(arr, left, mid, right); //合并 &#125; /** * 合并两个有序数组 * @param arr 待合并数组 * @param left 左指针 * @param mid 中间指针 * @param right 右指针 */ public static void merge(int[] arr, int left, int mid, int right) &#123; //[left, mid] [mid+1, right] int[] temp = new int[right - left + 1]; //中间数组 int i = left; int j = mid + 1; int k = 0; while(i &lt;= mid &amp;&amp; j &lt;= right) &#123; if(arr[i] &lt;= arr[j]) &#123; temp[k++] = arr[i++]; &#125; else &#123; temp[k++] = arr[j++]; &#125; &#125; while(i &lt;= mid) &#123; temp[k++] = arr[i++]; &#125; while(j &lt;= right) &#123; temp[k++] = arr[j++]; &#125; for(int p=0; p&lt;temp.length; p++) &#123; arr[left + p] = temp[p]; &#125; &#125;&#125; C++实现代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124//非递归实现：#include&lt;iostream&gt;#include&lt;ctime&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;using namespace std;/**将a开头的长为length的数组和b开头长为right的数组合并n为数组长度，用于最后一组*/void Merge(int* data,int a,int b,int length,int n)&#123; int right; if(b+length-1 &gt;= n-1) right = n-b; else right = length; int* temp = new int[length+right]; int i=0, j=0; while(i&lt;=length-1 &amp;&amp; j&lt;=right-1)&#123; if(data[a+i] &lt;= data[b+j])&#123; temp[i+j] = data[a+i];i++; &#125; else&#123; temp[i+j] = data[b+j]; j++; &#125; &#125; if(j == right)&#123;//a中还有元素，且全都比b中的大,a[i]还未使用 memcpy(temp + i + j, data + a + i, (length - i) * sizeof(int)); &#125; else if(i == length)&#123; memcpy(temp + i + j, data + b + j, (right - j)*sizeof(int)); &#125; memcpy(data+a, temp, (right + length) * sizeof(int)); delete [] temp;&#125;void MergeSort(int* data, int n)&#123; int step = 1; while(step &lt; n)&#123; for(int i=0; i&lt;=n-step-1; i+=2*step) Merge(data, i, i+step, step, n); //将i和i+step这两个有序序列进行合并 //序列长度为step //当i以后的长度小于或者等于step时，退出 step*=2;//在按某一步长归并序列之后，步长加倍 &#125;&#125;int main()&#123; int n; cin&gt;&gt;n; int* data = new int[n]; if(!data) exit(1); int k = n; while(k--)&#123; cin&gt;&gt;data[n-k-1]; &#125; clock_t s = clock(); MergeSort(data, n); clock_t e = clock(); k=n; while(k--)&#123; cout&lt;&lt;data[n-k-1]&lt;&lt;&apos; &apos;; &#125; cout&lt;&lt;endl; cout&lt;&lt;&quot;the algorithm used&quot;&lt;&lt;e-s&lt;&lt;&quot;miliseconds.&quot;&lt;&lt;endl; delete data; return 0;&#125;//递归实现：#include&lt;iostream&gt;using namespace std;void merge(int *data, int start, int mid, int end, int *result)&#123; int i, j, k; i = start; j = mid + 1; //避免重复比较data[mid] k = 0; while (i &lt;= mid &amp;&amp; j &lt;= end) //数组data[start,mid]与数组(mid,end]均没有全部归入数组result中去 &#123; if (data[i] &lt;= data[j]) //如果data[i]小于等于data[j] result[k++] = data[i++]; //则将data[i]的值赋给result[k]，之后i,k各加一，表示后移一位 else result[k++] = data[j++]; //否则，将data[j]的值赋给result[k]，j,k各加一 &#125; while (i &lt;= mid) //表示数组data(mid,end]已经全部归入result数组中去了，而数组data[start,mid]还有剩余 result[k++] = data[i++]; //将数组data[start,mid]剩下的值，逐一归入数组result while (j &lt;= end) //表示数组data[start,mid]已经全部归入到result数组中去了，而数组(mid,high]还有剩余 result[k++] = data[j++]; //将数组a[mid,high]剩下的值，逐一归入数组result for (i = 0; i &lt; k; i++) //将归并后的数组的值逐一赋给数组data[start,end] data[start + i] = result[i]; //注意，应从data[start+i]开始赋值&#125;void merge_sort(int *data, int start, int end, int *result)&#123; if (start &lt; end) &#123; int mid = start + (end-start) / 2;//避免溢出int merge_sort(data, start, mid, result); //对左边进行排序 merge_sort(data, mid + 1, end, result); //对右边进行排序 merge(data, start, mid, end, result); //把排序好的数据合并 &#125;&#125;void amalgamation(int *data1, int *data2, int *result)&#123; for (int i = 0; i &lt; 10; i++) result[i] = data1[i]; for (int i = 0; i &lt; 10; i++) result[i + 10] = data2[i];&#125;int main()&#123; int data1[10] = &#123; 1,7,6,4,9,14,19,100,55,10 &#125;; int data2[10] = &#123; 2,6,8,99,45,63,102,556,10,41 &#125;; int *result = new int[20]; int *result1 = new int[20]; amalgamation(data1, data2, result); for (int i = 0; i &lt; 20; ++i) cout &lt;&lt; result[i] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; merge_sort(result, 0, 19, result1); for (int i = 0; i &lt; 20; ++i) cout &lt;&lt; result[i] &lt;&lt; &quot; &quot;; delete[]result; delete[]result1; return 0;&#125; 计数排序&emsp;&emsp;如果在面试中有面试官要求你写一个O(n)时间复杂度的排序算法，你千万不要立刻说：这不可能！虽然前面基于比较的排序的下限是O(nlogn)。但是确实也有线性时间复杂度的排序，只不过有前提条件，就是待排序的数要满足一定的范围的整数，而且计数排序需要比较多的辅助空间。其基本思想是，用待排序的数作为计数数组的下标，统计每个数字的个数。然后依次输出即可得到有序序列。java实现代码如下：123456789101112131415161718192021222324252627282930313233343536/** *@Description:&lt;p&gt;计数排序算法实现&lt;/p&gt; *@author Eric Zhang *@time 2018-11-17 下午17：31：39 */public class CountSort &#123; public static void countSort(int[] arr) &#123; if(arr == null || arr.length == 0) return ; int max = max(arr); int[] count = new int[max+1]; Arrays.fill(count, 0); for(int i=0; i&lt;arr.length; i++) &#123; count[arr[i]] ++; &#125; int k = 0; for(int i=0; i&lt;=max; i++) &#123; for(int j=0; j&lt;count[i]; j++) &#123; arr[k++] = i; &#125; &#125; &#125; public static int max(int[] arr) &#123; int max = Integer.MIN_VALUE; for(int ele : arr) &#123; if(ele &gt; max) max = ele; &#125; return max; &#125;&#125; C++实现代码如下：123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;const int MAXN = 100000;const int k = 1000; // rangeint a[MAXN], c[MAXN], ranked[MAXN]; int main() &#123; int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; a[i]; ++c[a[i]]; &#125; for (int i = 1; i &lt; k; ++i) c[i] += c[i-1]; for (int i = n-1; i &gt;= 0; --i) ranked[--c[a[i]]] = a[i];//如果是i表达的是原数标号，a[i]就是排序后的正确序列 for (int i = 0; i &lt; n; ++i) cout &lt;&lt; ranked[i] &lt;&lt; endl; return 0;&#125;","categories":[{"name":"排序算法","slug":"排序算法","permalink":"http://excu4fun.com/categories/排序算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://excu4fun.com/tags/算法/"}]},{"title":"OC笔记（三）","slug":"grammar_oc1","date":"2018-11-14T16:00:00.000Z","updated":"2018-11-15T12:47:56.317Z","comments":true,"path":"2018/11/15/grammar_oc1/","link":"","permalink":"http://excu4fun.com/2018/11/15/grammar_oc1/","excerpt":"","text":"Objective-c中 isEqual ，isEqualToString ， == 三者的区别&emsp;&emsp;OC中的对象都是用指针表示，方法的调用是基于消息机制实现，== 比较的自然是指针指向的地址&emsp;&emsp;isEqual 和 isEqualToString 的区别：IsEqual 是 NSObject 的方法 ，而 isEqualToString 是 NSString 的方法因此从继承关系角度来说isEqualToString 是 isEqual 的衍生方法首先都会判断 指针是否相等 ，相等直接返回YES，不相等再判断是否是同类对象或非空，空或非同类对象直接返回NO，而后依次判断对象对应的属性是否相等，若均相等，返回YES这样就不难理解 isEqualToString 的实现内部的了最后解释 HashCode 和 isEqual 的关系hash和isEqual:方法都在NSObject协议中声明，且彼此关系紧密。实现hash方法必须返回一个整型数(NSInterger)，作为哈希表结构中的表地址。两个对象相等（isEqual:方法的判断结果）意味着它们有相同的哈希值。如果哈希值相同，两个对象不一定相等。如果您的对象可能被包含在象NSSet这样的集合中，则需要定义hash方法，比如UIWebView并确保该方法在两个对象相等的时候返回相同的哈希值。 举个栗子：123456789101112131415161718192021NSString *appleIdStr = @&quot;&quot;;NSMutableDictionary * params = [NSMutableDictionary dictionary]; if ([productID isEqualToString:@&quot;hjzd_1_1&quot;])&#123; appleIdStr = @&quot;com.xys.6&quot;; &#125; else if([productID isEqualToString:@&quot;hjzd_1_2&quot;])&#123; appleIdStr = @&quot;com.xys.30&quot;; &#125; else if([productID isEqualToString:@&quot;hjzd_1_3&quot;])&#123; appleIdStr = @&quot;com.xys.98&quot;; &#125; else if([productID isEqualToString:@&quot;hjzd_1_4&quot;])&#123; appleIdStr = @&quot;com.xys.198&quot;; &#125; else if([productID isEqualToString:@&quot;hjzd_1_5&quot;])&#123; appleIdStr = @&quot;com.xys.328&quot;; &#125; else if([productID isEqualToString:@&quot;hjzd_1_6&quot;])&#123; appleIdStr = @&quot;com.xys.648&quot;; &#125; params[@&quot;billing_point_id&quot;] = appleIdStr;","categories":[{"name":"IOS","slug":"IOS","permalink":"http://excu4fun.com/categories/IOS/"}],"tags":[{"name":"IOS","slug":"IOS","permalink":"http://excu4fun.com/tags/IOS/"}]},{"title":"OC笔记（一）","slug":"NSDictionary","date":"2018-11-14T16:00:00.000Z","updated":"2018-11-15T13:28:15.709Z","comments":true,"path":"2018/11/15/NSDictionary/","link":"","permalink":"http://excu4fun.com/2018/11/15/NSDictionary/","excerpt":"","text":"&emsp;&emsp;因为这几天再做有关ios相关的工作，发现json的数据格式与OC中的字典和数组很像，代码中经常用字典来接收解析服务器端请求过来的json数据，在此记录一下不可变字典（NSDictionary）与可变字典(NSMutableDictionary)的一些基本用法。 不可变字典（NSDictionary）与可变字典(NSMutableDictionary) 一、不可变字典(NSDictionary)1)初始化方法创建1NSDictionary *dic1 = [[NSDictionary alloc] initWithObjectsAndKeys:@&quot;张三&quot;, @&quot;name&quot;, @&quot;man&quot;, @&quot;gender&quot;, @&quot;22&quot;, @&quot;age&quot;, nil]; 2)便利构造器创建1NSDictionary *dic2 = [NSDictionary dictionaryWithObjectsAndKeys:@&quot;Chengdu&quot;, @&quot;city&quot;, @&quot;178&quot;, @&quot;height&quot;,@&quot;120&quot;, @&quot;weight&quot;, nil]; 3)字面量方式1NSDictionary *dic3 = @&#123;@&quot;date&quot; : @&quot;2018-11-15&quot;, @&quot;content&quot; : @&quot;Winter&quot;, @&quot;imageURL&quot; : @&quot;www.excu4fun.com/image/winter.png&quot;&#125;; 字典无序，键值对不分先后。 二、字典常用方法12345678910111213141516171819// 1) 获取字典中键值对个数NSUInteger num = [dic1 count];NSLog(@&quot;%lu&quot;, num);// 2) 获取字典中所有的键NSArray *array = dic1.allKeys; // [dic1 allKeys]NSLog(@&quot;%@&quot;, array);// 3) 获取字典中所有的值NSArray *array2 = [dic1 allValues]; // dic1.allValuesNSLog(@&quot;%@&quot;, array2);// 4) 获取指定的key所对应的valueNSString *str = [dic2 objectForKey:@&quot;image&quot;];NSLog(@&quot;%@&quot;,str); 三、可变字典的创建1)初始化方法创建1NSMutableDictionary *dic1 = [[NSMutableDictionary alloc] initWithObjectsAndKeys:@&quot;Reus&quot;, @&quot;name&quot;, @&quot;29&quot;, @&quot;age&quot;, @&quot;LWN&quot;, @&quot;location&quot;, nil]; 2)便利构造器创建1NSMutableDictionary *dic2 = [NSMutableDictionary dictionaryWithObjectsAndKeys:@&quot;Götze&quot;, @&quot;name&quot;, @&quot;Dortmund&quot;, @&quot;team&quot;, @&quot;AMC&quot;, @&quot;location&quot;, nil]; 3)字面量方式1NSMutableDictionary *dic3 = [@&#123;@&quot;姓名&quot; : @&quot;武磊&quot;, @&quot;位置&quot; : @&quot;前锋&quot;, @&quot;年龄&quot; : @&quot;27&quot;&#125; mutableCopy]; 四、可变字典的方法12345678910111213// 1) 根据 Key 值修改 value[dic3 setObject:@&quot;周鹏&quot; forKey:@&quot;姓名1&quot;]; // 本方法不仅可以修改已经存在的key的value,还可以添加新的 键值对儿.NSLog(@&quot;%@&quot;, [dic3 objectForKey:@&quot;姓名&quot;]);// 2) 移除指定key的键值对[dic3 removeObjectForKey:@&quot;姓名1&quot;];NSLog(@&quot;%@&quot;, dic3);// 3) 移除所有键值对[dic3 removeAllObjects];NSLog(@&quot;%@&quot;, dic3); 举个栗子：12345678910111213141516171819202122232425262728293031-(void) loginComplete:(int)errcode userData:(NSMutableDictionary *)_userData&#123; NSLog(@&quot;errcode: %d&quot;,errcode); NSLog(@&quot;userData: %@&quot;,_userData); if(errcode==0) &#123; NSLog(@&quot;Logged in&quot;); if(CGameSdk::getInstance()-&gt;getLoginhandler()&gt;0) &#123; cocos2d::LuaStack *pStack = cocos2d::LuaEngine::getInstance()-&gt;getLuaStack(); if(NULL == pStack)&#123; return; &#125; int nRet = 0; //解析NSMutableDictionary并转换为char* const char *playerID = [[_userData objectForKey:@&quot;user_id&quot;] UTF8String]; const char *userToken = [[_userData objectForKey:@&quot;token&quot;] UTF8String]; pStack-&gt;pushBoolean(true); cocos2d::LuaValueDict contactEvent; contactEvent.insert(contactEvent.end(),cocos2d::LuaValueDict::value_type (&quot;login&quot;,cocos2d::LuaValue::intValue(1))); contactEvent.insert(contactEvent.end(),cocos2d::LuaValueDict::value_type (&quot;uid&quot;,cocos2d::LuaValue::stringValue(playerID))); contactEvent.insert(contactEvent.end(),cocos2d::LuaValueDict::value_type (&quot;token&quot;,cocos2d::LuaValue::stringValue(userToken))); pStack-&gt;pushLuaValueDict(contactEvent); nRet = pStack-&gt;executeFunctionByHandler(CGameSdk::getInstance()-&gt;getLoginhandler(), 2); pStack-&gt;clean(); &#125; &#125;&#125;","categories":[{"name":"IOS","slug":"IOS","permalink":"http://excu4fun.com/categories/IOS/"}],"tags":[{"name":"IOS","slug":"IOS","permalink":"http://excu4fun.com/tags/IOS/"}]},{"title":"Sandbox沙盒账号支付失败，提示：无法连接到itunes store","slug":"sandBox","date":"2018-11-14T16:00:00.000Z","updated":"2018-11-15T13:20:22.188Z","comments":true,"path":"2018/11/15/sandBox/","link":"","permalink":"http://excu4fun.com/2018/11/15/sandBox/","excerpt":"","text":"原文：白马斩辰 沙盒账号测试支付，有时候会遇到无法支付，提示 无法连接到itunes商店。本文将介绍一下解决问题的方法，顺便也会整理一些沙盒账号的相关知识。 1.沙盒账号怎么来的2.如何使用沙盒账号3.无法连接到itunes商店的解决 ———————-1.沙盒账号怎么来的———————- 沙盒账号，是苹果为了方便开发者进行IAP支付测试，而提供的一种账号。使用沙盒账号进行支付时，与真正购买商品是同样的流程，因此可以用来验证整个IAP支付流程。沙盒账号在苹果后台添加 添加沙盒账号时，输入一个邮箱，创建一个支付密码。注意：1231.如果你的应用限定在某些国家发售，那么沙盒账号注意选择正确的国别。2.沙盒账号不要用已有的appstore账号3.沙盒账号可以是不存在的邮箱，只要格式正确即可，例如 1@qq.com ———————2.如何使用沙盒账号—————————- 要使用沙盒账号进行测试，首先要配置IAP商品，保证客户端provisioning证书正确。 如果你需要服务器进行三方验证，那么还要搭建好服务器。注意：沙盒账号支付时，连接到苹果接口是不同的，对比一下12https://sandbox.itunes.apple.com/verifyReceipt 沙盒订单验证接口https://buy.itunes.apple.com/verifyReceipt 正式订单验证接口 一切准备就绪后，在客户端点击商品，输入沙盒账号密码进行购买，购买成功则说明整个流程正确。 ———————-3.无法连接到itunes商店的解决————————–客户端进行sandbox测试时，经常遇到提示 “无法连接到itunes store”这里列举一下不同原因，以及解决方法：121.购买商品时，Product ID写错了 解决方法：测试时打印出日志，注意查看Product ID是否正确 1232.证书配置错误 解决方法：App ID中，一定要打开IAP的Development配置 一定要用Development类型的证书，且一定要在App ID设置后才生成证书 ![setRoleST][https://img-blog.csdn.net/20150731204849023] 123453.沙盒账号使用错误 解决方法：正确使用沙盒账号。 a.请确保你使用的是沙盒账号，而不是appstore的账号。这个问题很常见 b.如果设备上已经登录了appstore账号，在设置中注销。 c.在你的应用中点击购买商品，弹出框内输入沙盒账号、密码 1234.网络不好 解决方法：切换一下网络，wifi、4g等都试试。 苹果服务器在国内确实不稳定，如果总是不OK，那就隔天再测吧","categories":[{"name":"IOS","slug":"IOS","permalink":"http://excu4fun.com/categories/IOS/"}],"tags":[{"name":"IOS","slug":"IOS","permalink":"http://excu4fun.com/tags/IOS/"}]},{"title":"OC笔记（二）","slug":"typeConversion","date":"2018-11-14T16:00:00.000Z","updated":"2018-11-15T12:30:25.333Z","comments":true,"path":"2018/11/15/typeConversion/","link":"","permalink":"http://excu4fun.com/2018/11/15/typeConversion/","excerpt":"","text":"一、NSString转化为UNICODE String12345(NSString*)fname ＝ @“Test”;char fnameStr[10];memcpy(fnameStr, [fname cStringUsingEncoding:NSUnicodeStringEncoding], 2*([fname length]));//memcpy并不是遇到&apos;\\0&apos;就结束，而是一定会拷贝完n个字节 二、NSString 与 char *互相转化123456//NSString 转化为 char *NSString * str＝ @“Test”;const char * a =[str UTF8String];//char * 转化为 NSStringNSString *str=[NSString stringWithCString encoding:NSUTF8StringEncoding]; 三、char * 与 NSData互相转化1234567891011//char * 转化 NSData方法一：char * a = (char*)malloc(sizeof(byte)*16);NSData *data = [NSData dataWithBytes: a length:strlen(a)];//char * 转化 NSData方法二：- (id)initWithUTF8String:(const char *)bytes //转换为NSString- (NSData *)dataUsingEncoding:(NSStringEncoding)encoding // 然后用NSString的//NSData 转化 char *NSData data ；char* a=[data bytes]; 四、NsData 与 NSString互相转化123456//NSData 转化 NSStringNSData* data;NSString* aStr= ［NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];//NSString 转化 NSData对象NSData* xmlData = [@&quot;testdata&quot; dataUsingEncoding:NSUTF8StringEncoding]; 五、 NSString输出CGPoint123UIButton *buttn=[UIButtonbuttonWithType:UIButtonTypeRoundedRect];buttn.frame=CGRectMake(0, 2, 100, 100);NSLog(@&quot;===%@&quot;,NSStringFromCGRect(buttn.frame)); //输出CGpoint和CGrect 六、 中文与utf8相互转换123456NSString *str=@&quot;老大-老二&quot;;NSString *ss=[str stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding]; //向网络传中文字符串要转换为utf8字符串再传,utf8码也是放在nsstring里的NSString *str2=[ss stringByReplacingPercentEscapesUsingEncoding:NSUTF8StringEncoding]; //utf8转换成中文字符串NSLog(@&quot;%@++\\n&quot;,str);NSLog(@&quot;%@--\\n&quot;,ss);NSLog(@&quot;%@==\\n&quot;,str2); 七、 NSString转换成NSArray1234NSArray *array=[str componentsSeparatedByString:@&quot;-&quot;]; for (int i=0; i&lt;2; i++) &#123; NSLog(@&quot;++%@++\\n&quot;,[array objectAtIndex:i]); &#125; 八、 NSString 与 NSURL互相转化12345678910111213141516171819202122232425262728293031323334353637383940414243//NSString 转化 NSURL NSString *urlString=[@&quot;http://www.google.com/search?client=safari&amp;rls=en&amp;q=搜索&amp;ie=UTF-8&amp;oe=UTF-8&quot;stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];NSURL *url = [NSURL URLWithString:urlString];//NSURL 转化 NSStringNSString *s=[[url absoluteString] stringByReplacingPercentEscapesUsingEncoding:NSUTF8StringEncoding];NSArray *arr = [urlString componentsSeparatedByString:@&quot;&amp;&quot;]; NSURL *url = [NSURL URLWithString:[[arr objectAtIndex:0] stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding ]]; NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url]; [request setHTTPMethod:@&quot;POST&quot;]; NSMutableArray *_array = [[NSMutableArray alloc] initWithCapacity:0]; for (int i = 1; i &lt; [arr count]; ++i )&#123; NSString *str = [arr objectAtIndex:i]; [_array addObject:str]; &#125; [_array componentsJoinedByString:@&quot;&amp;&quot;]; NSData *data = [[_array componentsJoinedByString:@&quot;&amp;&quot;] dataUsingEncoding: NSASCIIStringEncoding]; [request setHTTPBody:data];// 发送请求并获得服务器反馈的数据NSData *urldata = [AESEnCDeCViewController Get:url];// 第一种 转换NSData数据到char*字符串char * test = (char*)[urldata bytes];std::string old = deaes(test);// 第二种 转换NSData到UTF8编码的NSString中再转换为char*字符串NSString *desStr = [[NSString alloc] initWithData:urldata encoding:NSUTF8StringEncoding];const char *desresult = [desStr UTF8String];std::string old = deaes(desresult); // 解密字字符串到明文NSString *oldstr = [[NSString alloc] initWithCString:old.c_str()];//很多时候软件读取的中文网页编码集是gb2312，所以显示出来的是乱码。这时需要将NSString文字编码转换1 NSURL *url = [NSURL URLWithString:urlStr];2 NSData *data = [NSData dataWithContentsOfURL:url]; 3 NSStringEncoding enc = CFStringConvertEncodingToNSStringEncoding(kCFStringEncodingGB_18030_2000); 4 NSString *retStr = [[NSString alloc] initWithData:data encoding:enc];","categories":[{"name":"IOS","slug":"IOS","permalink":"http://excu4fun.com/categories/IOS/"}],"tags":[{"name":"IOS","slug":"IOS","permalink":"http://excu4fun.com/tags/IOS/"}]},{"title":"Fight When it’s Time to Fight. Be Gracious When It’s Time to Give In.","slug":"fight_and_give_up","date":"2018-10-31T16:00:00.000Z","updated":"2018-11-01T12:45:17.457Z","comments":true,"path":"2018/11/01/fight_and_give_up/","link":"","permalink":"http://excu4fun.com/2018/11/01/fight_and_give_up/","excerpt":"","text":"原作： Mark Suster 翻译：马超 原文：Entrepreneur &emsp;&emsp;在我第一次创业的时候我非常好斗。在我看来整个世界好像就是一个战场，我无时无刻不在准备着战斗。与房东斗，与债主斗，与董事会斗，与各个你所能想到的群体斗。但是随着我不断的成长，我越来越发现找到一个共同点比不断的斗争更有好处。 &emsp;&emsp;有两个人经常在我身旁尽最大的努力让我冷却下来，他们是我的COO Stuart Lander和CFO David Lapter。Stuart也有些好斗因子，但是之前做过律师的他懂得谈判与和解比打一场持久的战斗要好的多。我记得我们经常达成的一条共识就是——如果一定要转身，那么就优雅的转身。于是我形成了自己的一个思想：如果我要去战斗，那么我会如虎如狼直至胜利；但是如果一定要转身，那么我也将优雅从容的转身。 &emsp;&emsp;虽然你觉得不符合常理，但是许多人就喜欢在转身放弃时令各方都不愉快。 &emsp;&emsp;这类人往往没有意识到：你转身放弃已经意味着你失败了一次，如果你还在转身的那一瞬间弄得大家都发指，那么你不仅已经失败了两次而且还让别人在背后骂你混蛋彻底毁掉你的形象。 &emsp;&emsp;公司的日常运营中就有许多类似的情况需要智慧处理。打个比方，你公司的一位高层员工要求加薪，而你不太喜欢他提出加薪的方式。你有许多种选择：礼貌拒绝，妥协答应。当然这不是本文的重点。本文想说的重点就是如果你确实打算妥协加薪，那么不要表现的像个怒发鬼或者小气鬼，你应该衷心的表达你对他们优秀工作的谢意。最差却又有许多人经常造成的后果就是自己给员工加了薪却还让员工指指骂骂。 &emsp;&emsp;需要优雅转身的情况太多了，朋友们可以各种去想。 &emsp;&emsp;今天下午发生的一件事就再次让我想到了人们是如何失败两次的： &emsp;&emsp;我住的酒店有两个游泳池，一个大人专用，一个允许小孩用。但是不幸的是小孩经常两边窜。我们打算去游泳的时候大人专用泳池就宣布暂时关闭，据说原因是有个小孩在里面拉了粑粑。我想既然已经拉了，你还有什么办法呢？ &emsp;&emsp;可是这时我边上的一位女士就不答应了。她嘟嘟嚷嚷着拉了粑粑也可以游泳，说：“一点小孩的粑粑不会伤害任何人吧？”我可以毫不夸张的说她在那里吵吵闹闹有半个小时。很明显，这位女士失败了两次，第一次是没游上泳，第二次是因为没游上泳引发的怒发冲冠。 &emsp;&emsp;就像在高速路上有车子突然插到你前面去一样，你又能做什么呢？再插到他前面去？和他飙车？那你自己也是在玩命。 &emsp;&emsp;生活中有许多事你要是走错了路，你就失败了两次。想清楚战斗和转身的不同。该战斗的时候就战斗，该转身的时候就转身，而且请务必保持优雅。","categories":[{"name":"文摘","slug":"文摘","permalink":"http://excu4fun.com/categories/文摘/"}],"tags":[{"name":"文摘","slug":"文摘","permalink":"http://excu4fun.com/tags/文摘/"}]},{"title":"Markdown基础语法","slug":"mark-down","date":"2018-10-25T16:00:00.000Z","updated":"2018-10-27T02:59:27.941Z","comments":true,"path":"2018/10/26/mark-down/","link":"","permalink":"http://excu4fun.com/2018/10/26/mark-down/","excerpt":"","text":"前言：为什么你应该用Markdown写作? &emsp;&emsp;Markdown是一种纯文本格式的标记语言，这是它的优点之一，只要是支持Markdown的地方都恩能够获得相同的编辑效果，有利于文本迁移，方便写作者排版，相信以后越来越多的平台都将支持Markdown编辑模式。 一、标题&emsp;&emsp;在标题文字前面加#来表示这是一个标题，Markdown支持6级标题，示例：123456#这是一级标题##这是二级标题###这是三级标题####这是四级标题#####这是五级标题######这是六级标题 &emsp;&emsp;效果如下： 这是一级标题这是二级标题这是三级标题这是四级标题这是五级标题这是六级标题二、字体·加粗用两个*将要加粗的文字包括起来 ·斜体用一个*将要倾斜的文字包括起来 ·斜体加粗用三个*将要倾斜加粗的文字包括起来 ·删除线用两个~将要加删除线的文字包括起来 &emsp;&emsp;示例：1234**这是要加粗的文字***这是倾斜的文字****这是斜体加粗的文字***~~这是加删除线的文字~~ &emsp;&emsp;效果如下：这是要加粗的文字这是倾斜的文字这是斜体加粗的文字这是加删除线的文字 三、引用&emsp;&emsp;在要加引用的文字前加&gt;&emsp;&emsp;示例：1&gt;这是引用的内容 &emsp;&emsp;效果如下： 这是引用的内容 四、分割线&emsp;&emsp;使用三个或三个以上的-或*&emsp;&emsp;示例：1234-----------*********** 五、图片&emsp;&emsp;插入图片语法：1231.[图片描述](图片地址&quot;图片tittle&quot;)图片票数为图片下面显示的文字。图片title为图片标题，可省略。 &emsp;&emsp;示例：1![sea](http://wx4.sinaimg.cn/mw690/0060lm7Tly1fwlvcahj2jj31i610418d.jpg) &emsp;&emsp;效果如下： 六、超链接&emsp;&emsp;语法：1[链接名](链接地址) &emsp;&emsp;示例：1[excu4fun](https://excu4fun.com) &emsp;&emsp;效果如下：excu4fun 七、表格&emsp;&emsp;语法：123456|姓名|技能|排行|| - | - | - | |刘备|哭|老大||关羽|打|老二||张飞|骂|老三|第二行的-有一个就够，为了对齐可以多加了几个 &emsp;&emsp;效果如下： 姓名 技能 排行 刘备 哭 老大 关羽 打 老二 张飞 骂 老三 八、代码&emsp;&emsp;语法：&emsp;&emsp;单行代码：代码之间用`包括起来1`This is a example` &emsp;&emsp;代码块：代码之间用123456```(```)This is a exampleThis is a example(```)括号是省略内容，为了方便显示效果，实际使用去掉括号 &emsp;&emsp;效果：&emsp;&emsp;单行代码：This is a example&emsp;&emsp;代码块：12This is a exampleThis is a example 九、流程图&emsp;&emsp;示例：1234567891011(```)flowst=&gt;start: Startop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?e=&gt;Endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op(```)括号为防止转译，实际使用忽略 &emsp;&emsp;可使用Markdown文本编辑器来生成流程图，效果如下： 十、背景及字体&emsp;&emsp;语法：1234&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=#A9A9A9&gt;这是需要加背景颜色的文字&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;font color=#FFFF00 size=6&gt;这是字体&lt;/font&gt; &emsp;&emsp;效果如下： 这是需要加背景颜色的文字 这是字体 &emsp;&emsp;附上颜色名列表： 颜色名 十六进制颜色值 颜色 AliceBlue #F0F8FF rgb(240, 248, 255) AntiqueWhite #FAEBD7 rgb(250, 235, 215) Aqua #00FFFF rgb(0, 255, 255) Aquamarine #7FFFD4 rgb(127, 255, 212) Azure #F0FFFF rgb(240, 255, 255) Beige #F5F5DC rgb(245, 245, 220) Bisque #FFE4C4 rgb(255, 228, 196) Black #000000 rgb(0, 0, 0) BlanchedAlmond #FFEBCD rgb(255, 235, 205) Blue #0000FF rgb(0, 0, 255) BlueViolet #8A2BE2 rgb(138, 43, 226) Brown #A52A2A rgb(165, 42, 42) BurlyWood #DEB887 rgb(222, 184, 135) CadetBlue #5F9EA0 rgb(95, 158, 160) Chartreuse #7FFF00 rgb(127, 255, 0) Chocolate #D2691E rgb(0, 255, 255) Coral #FF7F50 rgb(255, 127, 80) CornflowerBlue #6495ED rgb(100, 149, 237) Cornsilk #FFF8DC rgb(255, 248, 220) Crimson #DC143C rgb(220, 20, 60) Cyan #00FFFF rgb(0, 255, 255) DarkBlue #00008B rgb(0, 0, 139) DarkCyan #008B8B rgb(0, 139, 139) DarkGoldenRod #B8860B rgb(184, 134, 11) DarkGray #A9A9A9 rgb(169, 169, 169) DarkGreen #006400 rgb(0, 100, 0) DarkKhaki #BDB76B rgb(189, 183, 107) DarkMagenta #8B008B rgb(139, 0, 139) DarkOliveGreen #556B2F rgb(85, 107, 47) Darkorange #FF8C00 rgb(255, 140, 0) DarkOrchid #9932CC rgb(153, 50, 204) DarkRed #8B0000 rgb(139, 0, 0) DarkSalmon #E9967A rgb(233, 150, 122) DarkSeaGreen #8FBC8F rgb(143, 188, 143) DarkSlateBlue #483D8B rgb(72, 61, 139) DarkSlateGray #2F4F4F rgb(47, 79, 79) DarkTurquoise #00CED1 rgb(0, 206, 209) DarkViolet #9400D3 rgb(148, 0, 211) DeepPink #FF1493 rgb(255, 20, 147) DeepSkyBlue #00BFFF rgb(0, 191, 255) DimGray #696969 rgb(105, 105, 105) DodgerBlue #1E90FF rgb(30, 144, 255) Feldspar #D19275 rgb(209, 146, 117) FireBrick #B22222 rgb(178, 34, 34) FloralWhite #FFFAF0 rgb(255, 250, 240) ForestGreen #228B22 rgb(34, 139, 34) Fuchsia #FF00FF rgb(255, 0, 255) Gainsboro #DCDCDC rgb(220, 220, 220) GhostWhite #F8F8FF rgb(248, 248, 255) Gold #FFD700 rgb(255, 215, 0) GoldenRod #DAA520 rgb(218, 165, 32) Gray #808080 rgb(128, 128, 128) Green #008000 rgb(0, 128, 0) GreenYellow #ADFF2F rgb(173, 255, 47) HoneyDew #F0FFF0 rgb(240, 255, 240) HotPink #FF69B4 rgb(255, 105, 180) IndianRed #CD5C5C rgb(205, 92, 92) Indigo #4B0082 rgb(75, 0, 130) Ivory #FFFFF0 rgb(255, 255, 240) Khaki #F0E68C rgb(240, 230, 140) Lavender #E6E6FA rgb(230, 230, 250) LavenderBlush #FFF0F5 rgb(255, 240, 245) LawnGreen #7CFC00 rgb(124, 252, 0) LemonChiffon #FFFACD rgb(255, 250, 205) LightBlue #ADD8E6 rgb(173, 216, 230) LightCoral #F08080 rgb(240, 128, 128) LightCyan #E0FFFF rgb(224, 255, 255) LightGoldenRodYellow #FAFAD2 rgb(250, 250, 210) LightGrey #D3D3D3 rgb(211, 211, 211) LightGreen #90EE90 rgb(144, 238, 144) Linen #FAF0E6 rgb(250, 240, 230) Magenta #FF00FF rgb(255, 0, 255) Maroon #800000 rgb(128, 0, 0) MediumAquaMarine #66CDAA rgb(102, 205, 170) MediumBlue #0000CD rgb(0, 0, 205) MediumOrchid #BA55D3 rgb(186, 85, 211) MediumPurple #9370D8 rgb(147, 112, 216) MediumSeaGreen #3CB371 rgb(60, 179, 113) MediumSlateBlue #7B68EE rgb(123, 104, 238) MediumSpringGreen #00FA9A rgb(0, 250, 154) MediumTurquoise #48D1CC rgb(72, 209, 204) MediumVioletRed #C71585 rgb(199, 21, 133) MidnightBlue #191970 rgb(25, 25, 112) MintCream #F5FFFA rgb(245, 255, 250) MistyRose #FFE4E1 rgb(255, 228, 225) Moccasin #FFE4B5 rgb(255, 228, 181) NavajoWhite #FFDEAD rgb(255, 222, 173) Navy #000080 rgb(0, 0, 128) OldLace #FDF5E6 rgb(253, 245, 230) Olive #808000 rgb(128, 128, 0) OliveDrab #6B8E23 rgb(107, 142, 35) Orange #FFA500 rgb(255, 165, 0) OrangeRed #FF4500 rgb(255, 69, 0) Orchid #DA70D6 rgb(218, 112, 214) PaleGoldenRod #EEE8AA rgb(238, 232, 170) PaleGreen #98FB98 rgb(152, 251, 152) PaleTurquoise #AFEEEE rgb(175, 238, 238) PaleVioletRed #D87093 rgb(216, 112, 147) PapayaWhip #FFEFD5 rgb(255, 239, 213) PeachPuff #FFDAB9 rgb(255, 218, 185) Peru #CD853F rgb(205, 133, 63) Pink #FFC0CB rgb(255, 192, 203) Plum #DDA0DD rgb(221, 160, 221) PowderBlue #B0E0E6 rgb(176, 224, 230) Purple #800080 rgb(128, 0, 128) Red #FF0000 rgb(255, 0, 0) RosyBrown #BC8F8F rgb(188, 143, 143) RoyalBlue #4169E1 rgb(65, 105, 225) SaddleBrown #8B4513 rgb(139, 69, 19) Salmon #FA8072 rgb(250, 128, 114) SandyBrown #F4A460 rgb(244, 164, 96) SeaGreen #2E8B57 rgb(46, 139, 87) SeaShell #FFF5EE rgb(255, 245, 238) Sienna #A0522D rgb(160, 82, 45) Silver #C0C0C0 rgb(192, 192, 192) SkyBlue #87CEEB rgb(135, 206, 235) SlateBlue #6A5ACD rgb(106, 90, 205) SlateGray #708090 rgb(112, 128, 144) Snow #FFFAFA rgb(255, 250, 250) SpringGreen #00FF7F rgb(0, 255, 127) SteelBlue #4682B4 rgb(70, 130, 180) Tan #D2B48C rgb(210, 180, 140) Teal #008080 rgb(0, 128, 128) Thistle #D8BFD8 rgb(216, 191, 216) Tomato #FF6347 rgb(255, 99, 71) Turquoise #40E0D0 rgb(64, 224, 208) Violet #EE82EE rgb(238, 130, 238) VioletRed #D02090 rgb(208, 32, 144) Wheat #F5DEB3 rgb(245, 222, 179) White #FFFFFF rgb(255, 255, 255) WhiteSmoke #F5F5F5 rgb(245, 245, 245) Yellow #FFFF00 rgb(255, 255, 0) YellowGreen #9ACD32 rgb(154, 205, 50)","categories":[{"name":"Markdown","slug":"Markdown","permalink":"http://excu4fun.com/categories/Markdown/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://excu4fun.com/tags/Markdown/"}]},{"title":"学习新技术真的需要买书吗？","slug":"need-book","date":"2018-10-25T16:00:00.000Z","updated":"2018-10-26T03:09:41.435Z","comments":true,"path":"2018/10/26/need-book/","link":"","permalink":"http://excu4fun.com/2018/10/26/need-book/","excerpt":"","text":"&emsp;&emsp;IT行业，学习新技术，特别是像Android、ios开发这种每时每刻都在更新变化的技术，真的需要买书吗？ &emsp;&emsp;Android是开源的，本身就有很好的文档，如果看文档不过瘾，那直接看代码啊！学习这类东西，买书的话很不划算。写一本好的IT书籍需要花多长时间？一年？两年？五年？写出来之后还要校正排版印刷出版发行，等到你手里，书里的内容基本上也就过时了。几个月写出来的书能看吗？根据经验这类书都是翻译官方文档+复制原版示例代码而成。 &emsp;&emsp;记得以前大学的时候买过一本xxx开发指南，买过来看了两三天就丢抽屉里吃灰去了，完全没有看下去的欲望，现在已经不知道丢哪了。 &emsp;&emsp;所以，如果希望学习新技术，想破头在挑选买哪本书的朋友，先认真思考一下，真的有必要去买吗？特别是中文版。","categories":[{"name":"闲话","slug":"闲话","permalink":"http://excu4fun.com/categories/闲话/"}],"tags":[{"name":"闲话","slug":"闲话","permalink":"http://excu4fun.com/tags/闲话/"}]},{"title":"Time Or Money","slug":"time-or-money","date":"2018-10-21T16:00:00.000Z","updated":"2018-10-26T12:02:15.981Z","comments":true,"path":"2018/10/22/time-or-money/","link":"","permalink":"http://excu4fun.com/2018/10/22/time-or-money/","excerpt":"","text":"原作： J.D.Roth 翻译：翛凌 原文：Entrepreneur 关于作者J. D. Roth 《你的金钱：失落的使用手册》的作者。同时他也是个人金融博客 getrichslowly.org 的创立者和编辑。 &emsp;&emsp;「时间就是金钱，金钱就是时间」。这是 Joe Dominguez 和 Vicki Robin 合著的个人理财经典教程《你的金钱或你的时间》的中心思想。他们在书中写道，「金钱是我们选择通过耗费我们的能量这样一种方式来换取的东西。」 &emsp;&emsp;这两位作者的观点主要是这样的：你需要耗费时间才能获得金钱，因此你在买东西时花费的并不是你的金钱，而是你的时间。举例来说，假设你是一个一小时挣 50 美元的顾问，你买了一个价值 500 美元的 iPad。那么这个 iPad 实际上并不是花费了你 500 美元，而是耗费了你 10 小时的工作。如果你一小时只挣 25 美元，那么这个 iPad 实际上是时薪50美元的顾问的两倍，因为你需要工作 20 小时才能支付得起这个 iPad。 &emsp;&emsp;这种观点实际上有一些有力的实例。当你的花费变少的时候，你实际上可以工作得更少。节俭的人「买下」的时间比不节俭的人要多很多。 你的时间值多少钱？如果你是一个企业家，那么当你的生意越做越大的时候，你的时间也变得更为有价值。实际上你可以用一种非常简单的方式来计算你的时间的价值：假设你一周工作 h 小时，一年有 w 周。将你一整年的全部收入加起来，而后除以将你所有来源的收入加在一起，除以 ( h × w)，这就是你的时间所值的价钱。如果你需要做某件事情，计算一下究竟是你的时间更值钱还是请一个其他人做这个事情耗费的金钱更多。如果你的时间更值钱，那么就请人做这件事情。如果其他人的时间比较值钱，那么你还是自己来做这件事情吧。 &emsp;&emsp;实际上，有些精明的人已经发现了，极度节俭是一条能够让你实现提前退休的好方法。这再你的收入特别高的时尤为明显。如果你在二十多岁和三十多岁的时候能保证每月节省出至少一半甚至 70% 的工资时，你完全可以在 40 岁的时候退休，而不用像一般人一样 65 岁退休。 &emsp;&emsp;当然我们不可能每个人都适用这样的规律。但是从另一方面来说，金钱也可以买时间。Toni Anderson 又有一个叫做快乐主妇的网站。除了要管理这个逐渐扩大的网站，她还要照顾七个孩子。而她的丈夫，一名海军军官，却并不在她的身边，因此也无法帮助她照料事业和他们的七个孩子。Toni 也因此对时间和金钱之间的关系有着深刻的理解，所以在处理时间和金钱方面的平衡时非常有经验。 &emsp;&emsp;Toni 雇佣了以为助手去帮助她处理邮件并且帮助她整理生意上的一些细节（比如账单和募捐）。这样 Toni 就可以专注于处理她擅长的事情，也就是维持客户和消费者之间的关系。Toni 表示，「把你讨厌做的事情或者你不擅长做的事情委托给别人做就是其中的关键。」 &emsp;&emsp;像许多人一样，我花钱请了一个会计帮我管理我的税务问题。这不仅仅是因为他在这方面比我做得好、做得专业，而且还有个很重要的原因就是这只需要耗费他两个小时的时间。而如果要我自己处理这些问题，我可能需要 20 小时。同样，我还请了一个钟点工，每个月来我们家打扫两次房子。是的，请钟点工挺贵。不过这能让我花更多的时间去做那些我更擅长的、能拿到工资的工作。请钟点工能每个月让我多出几小时的空闲时间。而在这几小时内，我写了这篇文章。实际上，这篇文章的稿费够我请她在未来三个月内继续来我们家打扫卫生。 &emsp;&emsp;当然，在你刚开始一项事业的时候，比起金钱，你可能会拥有更多的时间。因此凡事亲力亲为、参与公司内的各项事务是非常合理的。但是一旦你的事业随着时间的推移逐渐做大，你的时间就会显得越来越少，而你的金钱则变得越来越多。此时花钱请一些员工去处理一些特定事情就变得非常有效。他们能帮助你分担一些你不擅长的工作，而你也能腾出更多时间处理你擅长的工作，获取更多的利润。 &emsp;&emsp;总结一下，在生活和工作上寻求平衡实际上就是平衡你使用金钱和使用时间的方式。如果买一个 iPad 只耗费你生命中 10 小时或者 20 小时的工作，那么买了 iPad 当然没有什么不可以。如果你需要工作更久的时间工作才能买得起这个 iPad ，那么请不要买这个 iPad 。就当帮自己一个忙：存下来这笔用来买 iPad 的钱。这样你以后就能早点退休，享受自己喜爱的生活了。","categories":[{"name":"文摘","slug":"文摘","permalink":"http://excu4fun.com/categories/文摘/"}],"tags":[{"name":"文摘","slug":"文摘","permalink":"http://excu4fun.com/tags/文摘/"}]},{"title":"Cocos2d-x3.10使用obb扩展包","slug":"android-obb","date":"2018-10-20T16:00:00.000Z","updated":"2018-10-22T07:06:27.466Z","comments":true,"path":"2018/10/21/android-obb/","link":"","permalink":"http://excu4fun.com/2018/10/21/android-obb/","excerpt":"","text":"一. 创建Obb文件并模拟下载环境1.1 Obb文件命名规则根据google官方的OBB文件命名规则来创建Obb文件：12&lt;main|patch&gt;.&lt;expansion-version&gt;.&lt;package-name&gt;.obb//例如：main.10001.com.demo.app.obb main|patch: main代表主扩展包，patch代表补充扩展包，一般只使用main关键字。expansion-version: 即version code。package-name: 包名。obb：后缀，本质为zip文件。 注意：上传google后台时，测试包的version code不能与正式包的version code相同，google不允许上传相同版本的app，即使其中一个是用来测试。 1.2 创建obb文件推荐使用winrar来创建obb文件，选择需要做成obb扩展包的资源文件，将其压缩，配置如下 注意：压缩文件格式选择”zip“，压缩方式选择”存储“ 1.3 本地模拟obb环境测试将创建好的obb文件放入手机sdcard/Android/obb/com.yourpackageName/目录下，如果本地没有相应目录，则手动创建即可（apk与obb上传google play后台之后，用户下载应用会自动创建相应目录）完成本地测试环境。 二. 修改引擎层代码Cocos2d-x3.16版本已添加读取obb文件功能，但3.16之前版本的则需要修改引擎部分代码才能读取obb文件 2.1 修改Java_org_cocos2dx_lib_Cocos2dxHelper.cpp在Java_org_cocos2dx_lib_Cocos2dxHelper.cpp中添加如下代码：1234567891011//添加obb pathstring g_obbPath//添加设置obbpath方法 JNIEXPORT void JNICALL Java_org_cocos2dx_lib_Cocos2dxHelper_nativeSetObbPath(JNIEnv* env, jobject thiz, jstring obbPath) &#123; g_obbPath = JniHelper::jstring2string(obbPath); &#125;//添加获取obbpath 方法const char * getObbPath()&#123; return g_obbPath.c_str();&#125; Java_org_cocos2dx_lib_Cocos2dxHelper.h中添加如下代码：12//添加方法extern const char * getObbPath(); 2.2 修改CCFileUtils-android.cpp在CCFileUtilsAndroid.h中添加：12#include \"base/ZipUtils.h\"//如要引入头文件，请确保Android.mk中配置了正确的路径 在CCFileUtilsAndroid.cpp中：12//创建全局指针变量obbFileZipFile *obbFile; 在构造函数FileUtilsAndroid::FileUtilsAndroid()中添加：1234FileUtilsAndroid::FileUtilsAndroid()&#123; obbFile = nullptr;&#125; 在析构函数FileUtilsAndroid::~FileUtilsAndroid()中添加：1234567FileUtilsAndroid::~FileUtilsAndroid()&#123; if(obbFile != nullptr) &#123; delete obbFile; obbFile = NULL; &#125;&#125; 有心的同学可以发现上述添加在之后的代码里中创建了一个单例模式 在isFileExistInternal()方法中做如下修改： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//引擎层代码不建议直接复制，建议与本地代码仔细比对后手动修改，注释部分用于方便看日志，可忽略bool FileUtilsAndroid::isFileExistInternal(const std::string&amp; strFilePath) const&#123; if (strFilePath.empty()) &#123; return false; &#125; bool bFound = false; // Check whether file exists in apk. if (strFilePath[0] != '/') &#123; const char* s = strFilePath.c_str(); // Found \"assets/\" at the beginning of the path and we dont want it if (strFilePath.find(_defaultResRootPath) == 0) s += strlen(\"assets/\"); if (FileUtilsAndroid::assetmanager) &#123; AAsset* aa = AAssetManager_open(FileUtilsAndroid::assetmanager, s, AASSET_MODE_UNKNOWN); if (aa) &#123; bFound = true; AAsset_close(aa); &#125;else&#123; if(getObbPath() != nullptr)&#123; // CCLOG(\"[AssetManager] ... in APK %s,%s, found = false! \\n obbPath=%s\", strFilePath.c_str(),s, getObbPath()); // ZipFile *obbFile = new ZipFile(getObbPath()); if (obbFile == nullptr) &#123; obbFile = new ZipFile(getObbPath()); &#125; if ( obbFile-&gt;fileExists(strFilePath.c_str()) ) &#123; // CCLOG(\"obb ... in APK %s, found = true!\", strFilePath.c_str()); bFound = true; // delete obbFile; // obbFile = NULL; &#125;else&#123; // CCLOG(\"obb ... in APK %s, found = false!\", strFilePath.c_str()); &#125; &#125; &#125; &#125; &#125; else &#123; FILE *fp = fopen(strFilePath.c_str(), \"r\"); if(fp) &#123; bFound = true; fclose(fp); &#125; &#125; return bFound;&#125; 在getData()方法中做如下修改： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123Data FileUtilsAndroid::getData(const std::string&amp; filename, bool forString)&#123; if (filename.empty()) &#123; return Data::Null; &#125; unsigned char* data = nullptr; ssize_t size = 0; string fullPath = fullPathForFilename(filename); if (fullPath[0] != '/') &#123; string relativePath = string(); size_t position = fullPath.find(\"assets/\"); if (0 == position) &#123; // \"assets/\" is at the beginning of the path and we dont want it relativePath += fullPath.substr(strlen(\"assets/\")); &#125; else &#123; relativePath += fullPath; &#125; LOGD(\"relative path = %s\", relativePath.c_str()); if (nullptr == FileUtilsAndroid::assetmanager) &#123; LOGD(\"... FileUtilsAndroid::assetmanager is nullptr\"); return Data::Null; &#125; // read asset data AAsset* asset = AAssetManager_open(FileUtilsAndroid::assetmanager, relativePath.c_str(), AASSET_MODE_UNKNOWN); if (nullptr != asset) &#123; off_t fileSize = AAsset_getLength(asset); if (forString) &#123; data = (unsigned char*) malloc(fileSize + 1); data[fileSize] = '\\0'; &#125; else &#123; data = (unsigned char*) malloc(fileSize); &#125; int bytesread = AAsset_read(asset, (void*)data, fileSize); size = bytesread; CCLOG(\"apk size test: size=%d;fileSize=%d\", size, fileSize); AAsset_close(asset); // return Data::Null; &#125;else&#123; CCLOG(\"asset is nullptr\"); ZipFile zipFile(getApkPath()); // CCLOG(\"guok special read: %s;forString=%d\", relativePath.c_str(), forString); string zFileNamePath = \"assets/\" + relativePath; // CCLOG(\"zFileNamePath =%s \",zFileNamePath.c_str()); // CCLOG(\"getObbPath() = %s\",getObbPath()); if ( zipFile.fileExists(zFileNamePath.c_str()) ) &#123; ssize_t fsize = 0 ; unsigned char* content = zipFile.getFileData(zFileNamePath.c_str(), &amp;fsize); // CCLOG(\"zipFile is exists!\"); if( fsize &gt; 0) &#123; // CCLOG(\"guok read success %d\", fsize); memcpy( data, content, fsize); size = fsize; &#125; else &#123; // CCLOG(\"guok read error %d\", fsize); &#125; if(content)free(content); &#125; else if(getObbPath() != nullptr)&#123; if (obbFile == nullptr) &#123; obbFile = new ZipFile(getObbPath()); &#125; // CCLOG(\"getObbPath() is exists!\"); string s = getObbPath(); string zObbNamePath = \"assets/\" + relativePath; // CCLOG(\"zObbNamePath = %s\",zObbNamePath.c_str()); if ( obbFile-&gt;fileExists(zObbNamePath.c_str()) ) &#123; ssize_t fsize = 0; unsigned char* content = obbFile-&gt;getFileData(zObbNamePath.c_str(), &amp;fsize); // CCLOG(\"obbFile is exists!\"); if( fsize &gt; 0) &#123; CCLOG(\"fsize = %d\",fsize); if (forString) &#123; data = (unsigned char*) malloc(fsize + 1); data[fsize] = '\\0'; // CCLOG(\"ssssssssssss\"); &#125;else&#123; data = (unsigned char*) malloc(fsize); // CCLOG(\"qqqqqqqqqqqqqqqqqqqq\"); &#125; memcpy( data, content, fsize); size = fsize; // CCLOG(\"obb getdata success %d\", fsize); &#125; else &#123; // CCLOG(\"obb getdata error %d\", fsize); &#125; if(content)free(content); &#125; &#125; if (size &lt;= 0) &#123; CCLOG(\"obb null size %d\", size); return Data::Null; &#125; &#125; &#125; else &#123; do &#123; ................... &#125; 在getFileData()方法中做如下修改： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114unsigned char* FileUtilsAndroid::getFileData(const std::string&amp; filename, const char* mode, ssize_t * size)&#123; unsigned char * data = 0; if ( filename.empty() || (! mode) ) &#123; return 0; &#125; string fullPath = fullPathForFilename(filename); if (fullPath[0] != '/') &#123; string relativePath = string(); size_t position = fullPath.find(\"assets/\"); if (0 == position) &#123; // \"assets/\" is at the beginning of the path and we dont want it relativePath += fullPath.substr(strlen(\"assets/\")); &#125; else &#123; relativePath += fullPath; &#125; LOGD(\"relative path = %s\", relativePath.c_str()); if (nullptr == FileUtilsAndroid::assetmanager) &#123; LOGD(\"... FileUtilsAndroid::assetmanager is nullptr\"); return nullptr; &#125; // read asset data AAsset* asset = AAssetManager_open(FileUtilsAndroid::assetmanager, relativePath.c_str(), AASSET_MODE_UNKNOWN); if (nullptr != asset) &#123; LOGD(\"asset is not nullptr\"); off_t fileSize = AAsset_getLength(asset); data = (unsigned char*) malloc(fileSize); int bytesread = AAsset_read(asset, (void*)data, fileSize); if (size) &#123; *size = bytesread; &#125; AAsset_close(asset); &#125; else &#123; LOGD(\"asset is nullptr\"); ZipFile zipFile(getApkPath()); CCLOG(\" special read: %s\", relativePath.c_str()); string zFileNamePath = \"assets/\" + relativePath; if ( zipFile.fileExists(zFileNamePath.c_str()) ) &#123; ssize_t fsize = 0; unsigned char* content = zipFile.getFileData(zFileNamePath.c_str(), &amp;fsize); if( fsize &gt; 0) &#123; // CCLOG(\"getfiledata success %d\", fsize); data = (unsigned char*) malloc(fsize); memcpy( data, content, fsize); if (size) &#123; *size = fsize; &#125; &#125; else &#123; CCLOG(\"getfiledata error %d\", fsize); &#125; if(content)free(content); &#125; else if(getObbPath() != nullptr)&#123; if (obbFile == nullptr) &#123; obbFile = new ZipFile(getObbPath()); &#125; string zObbNamePath = \"assets/\" + relativePath; // CCLOG(\"zObbNamePath = %s\",zObbNamePath.c_str()); if ( obbFile-&gt;fileExists(zObbNamePath.c_str()) ) &#123; ssize_t fsize = 0; unsigned char* content = obbFile-&gt;getFileData(zObbNamePath.c_str(), &amp;fsize); delete obbFile; obbFile = NULL; if( fsize &gt; 0) &#123; // CCLOG(\"obb getfiledata success %d\", fsize); data = (unsigned char*) malloc(fsize); memcpy( data, content, fsize); if (size) &#123; *size = fsize; &#125; &#125; else &#123; // CCLOG(\"obb getfiledata error %d\", fsize); &#125; if(content)free(content); &#125; &#125; &#125; if (!data) &#123; CCLOG(\"getFileData error: %s\", relativePath.c_str()); return nullptr; &#125; &#125; else &#123; do &#123; ................... &#125; 三. 修改安卓层代码准备工作：在Android Studio工程中导入google官方提供的库google_market_apk_expansion,具体可查看Android官方文档，所需的库可通过Android SDK Manager进行下载 3.1 在AndroidManifest.xml中配置相关权限123456&lt;uses-permission android:name=\"com.android.vending.CHECK_LICENSE\" /&gt;&lt;uses-permission android:name=\"android.permission.INTERNET\" /&gt;&lt;uses-permission android:name=\"android.permission.WAKE_LOCK\" /&gt;&lt;uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" /&gt;&lt;uses-permission android:name=\"android.permission.ACCESS_WIFI_STATE\"/&gt;&lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" / 3.2 在Cocos2dxActivity中添加变量及方法 123456789101112131415161718192021222324252627282930313233public static String FATE_OBB_PATH = \"\";public static String FATE_OBB_Name = \"\";@Override protected void onCreate(final Bundle savedInstanceState) &#123; FATE_OBB_Name = getObbFileName(); FATE_OBB_PATH = getVirtualObbFileFullpath(); super.onCreate(savedInstanceState); .... &#125; private String getObbFileName() &#123; PackageInfo info = null; try &#123; info = getPackageManager().getPackageInfo(getPackageName(), 0); String fileName = \"main.\" + info.versionCode + \".\" + getPackageName() + \".obb\"; Log.e(\"obb===fileName===\", fileName); return fileName; &#125; catch (NameNotFoundException e) &#123; e.printStackTrace(); &#125; return \"\"; &#125;private String getVirtualObbFileFullpath()&#123; String _path = \"\"; File file = getObbDir(); if(file == null || !file.exists())&#123; file.mkdirs(); &#125; _path = file.getPath() + \"/\" + getObbFileName(); Log.e(\"obb===_path===\", _path); return _path; &#125; 3.3 在Cocos2dxHelper中添加变量及方法 123public static ZipResourceFile obbzip = null;//使用需要外部依赖private static native void nativeSetObbPath(final String pObbPath);// nativeSetObbPath 设置obb路径方法 在init()中添加：12345678910111213141516171819202122232425262728293031323334353637383940public static void init(final Activity activity) &#123; if (!sInited) &#123; final ApplicationInfo applicationInfo = activity.getApplicationInfo(); Cocos2dxHelper.sCocos2dxHelperListener = (Cocos2dxHelperListener)activity; Cocos2dxHelper.sPackageName = applicationInfo.packageName; Cocos2dxHelper.sFileDirectory = activity.getFilesDir().getAbsolutePath(); Cocos2dxHelper.nativeSetApkPath(applicationInfo.sourceDir); Cocos2dxHelper.sCocos2dxAccelerometer = new Cocos2dxAccelerometer(activity); Cocos2dxHelper.sCocos2dMusic = new Cocos2dxMusic(activity); Cocos2dxHelper.sCocos2dSound = new Cocos2dxSound(activity); Cocos2dxHelper.sAssetManager = activity.getAssets(); if (fileIsExists(Cocos2dxActivity.FATE_OBB_PATH)) &#123; Cocos2dxHelper.nativeSetObbPath(Cocos2dxActivity.FATE_OBB_PATH); &#125; PackageInfo info = null; try &#123; info = activity.getPackageManager().getPackageInfo( activity.getPackageName(), 0); Cocos2dxHelper.obbzip = APKExpansionSupport .getAPKExpansionZipFile(activity, info.versionCode, 0); &#125; catch (PackageManager.NameNotFoundException e1) &#123; e1.printStackTrace(); &#125; catch (IOException e1) &#123; e1.printStackTrace(); &#125; Cocos2dxHelper.nativeSetContext((Context)activity, Cocos2dxHelper.sAssetManager); Cocos2dxBitmap.setContext(activity); Cocos2dxETCLoader.setContext(activity); sActivity = activity; sInited = true; &#125; &#125; 添加fileIsExists方法：123456789101112131415public static boolean fileIsExists(String strFile) &#123; if(strFile.isEmpty())&#123; return false; &#125; try &#123; File f = new File(strFile); if (!f.exists()) &#123; return false; &#125; &#125; catch (Exception e) &#123; return false; &#125; Log.d(\"obb\", \"file exist!\"); return true;&#125; 3.4 修改Cocos2dxMusic将1mediaPlayer.setDataSource(assetFileDescritor.getFileDescriptor(),assetFileDescritor.getStartOffset(), assetFileDescritor.getLength()); 替换为：12345678final AssetFileDescriptor assetFileDescritor = Cocos2dxHelper.obbzip.getAssetFileDescriptor(\"assets/\"+pPath); if(assetFileDescritor == null)&#123; final AssetFileDescriptor assetFileDescritor1 = this.mContext.getAssets().openFd(pPath); mediaPlayer.setDataSource(assetFileDescritor1.getFileDescriptor(), assetFileDescritor1.getStartOffset(), assetFileDescritor1.getLength()); &#125;else&#123; mediaPlayer.setDataSource(assetFileDescritor.getFileDescriptor(), assetFileDescritor.getStartOffset(), assetFileDescritor.getLength()); &#125; 3.5 修改Cocos2dxSound将1soundID = this.mSoundPool.load(this.mContext.getAssets().openFd(pPath), 0); 替换为：12345678910final AssetFileDescriptor assetFileDescritor = Cocos2dxHelper.obbzip .getAssetFileDescriptor(\"assets/\" + pPath); if (assetFileDescritor == null) &#123; final AssetFileDescriptor assetFileDescritor1 = this.mContext .getAssets().openFd(pPath); soundID = this.mSoundPool.load(assetFileDescritor1, 0); &#125; else &#123; soundID = this.mSoundPool.load(assetFileDescritor, 0); &#125; 3.6 在主Activity中添加代码12345678910111213141516171819private static final int REQUEST_EXTERNAL_STORAGE = 1;private static String[] PERMISSIONS_STORAGE = &#123; \"android.permission.READ_EXTERNAL_STORAGE\", \"android.permission.WRITE_EXTERNAL_STORAGE\" &#125;;public static void verifyStoragePermissions(Sprites activity) &#123; try &#123; //检测是否有写的权限 int permission = ActivityCompat.checkSelfPermission(activity, \"android.permission.WRITE_EXTERNAL_STORAGE\"); if (permission != PackageManager.PERMISSION_GRANTED) &#123; // 没有写的权限，去申请写的权限，弹出对话框 ActivityCompat.requestPermissions(activity, PERMISSIONS_STORAGE,REQUEST_EXTERNAL_STORAGE); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 在onCreate()中添加：12345678910111213141516171819202122232425262728293031323334//判断是否有sd卡读写权限，如果没有，则去申请！verifyStoragePermissions(Sprites.this); //检测是否已经下载到了obb包,如果没有，则弹出错误提示，killProcessif (Cocos2dxActivity.FATE_OBB_PATH.isEmpty() || !Cocos2dxHelper.fileIsExists(Cocos2dxActivity.FATE_OBB_PATH)) &#123; // 创建构建器 AlertDialog.Builder builder = new AlertDialog.Builder(this); // 设置参数 builder.setTitle(\"提示\").setIcon(R.drawable.icon) .setMessage(\"游戏资源已损坏，请重新下载！\") .setPositiveButton(\"退出\", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; // TODO Auto-generated method stub android.os.Process.killProcess(android.os.Process.myPid()); &#125; &#125;); builder.create().show(); new Handler().postDelayed(new Runnable()&#123; //延时3s退出程序 public void run() &#123; android.os.Process.killProcess(android.os.Process.myPid()); //execute the task &#125; &#125;, 3000); //如果未检测到obb包，延时3s后关闭程序&#125;/*这里最正确的方法应该是如果未检测到obb包，则去google后台手动下载，但这一部分的内容非常多而繁琐，在本篇中不进行详述，google官方表示不保证所有机型都可以下载得到obb包，因此需要添加手动下载的功能，通过公司的游戏实际检验，下载不到obb包的概率小于1%（当然这个统计不是很专业，也有可能有玩家没下载到obb包但没有反馈）如要添加此功能，需要依赖google配套的库，但是关于download方面的库年代已经很久远了，许多方法现在已经废弃，而google又一直没有升级过这个库，导致想要用需要自己手动去修改里面的n多错误，这将是件令人很头疼的问题，如果有时间，我会在之后的blog中记录如何实现这一过程*/ 总结完成以上修改之后，就可以先将obb包copy到手机相关目录下进行本地测试，没有问题就可以上传google beta测试包到googleplay后台去进行相关测试了，这部分内容是大学毕业进入公司后接手的第一个项目，全部完成用了一周的时间，之前公司一直是使用热更的方法来应对google的100Mapk上传限制，导致玩家每次都要下载一个很大的更新包，影响游戏体验，因此公司决定使用obb分包的方式上传apk，在此还要感谢老陈对我这个刚来的菜鸟的信任，将这份任务交给我，此致。","categories":[{"name":"Android","slug":"Android","permalink":"http://excu4fun.com/categories/Android/"}],"tags":[{"name":"Cocos2d-x","slug":"Cocos2d-x","permalink":"http://excu4fun.com/tags/Cocos2d-x/"},{"name":"Android","slug":"Android","permalink":"http://excu4fun.com/tags/Android/"}]}]}