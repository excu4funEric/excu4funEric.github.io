{"meta":{"title":"excu4funEric","subtitle":null,"description":null,"author":"Eric Zhang","url":"http://excu4fun.com"},"pages":[],"posts":[{"title":"学习新技术真的需要买书吗？","slug":"need-book","date":"2018-10-25T16:00:00.000Z","updated":"2018-10-26T03:09:41.435Z","comments":true,"path":"2018/10/26/need-book/","link":"","permalink":"http://excu4fun.com/2018/10/26/need-book/","excerpt":"","text":"&emsp;&emsp;IT行业，学习新技术，特别是像Android、ios开发这种每时每刻都在更新变化的技术，真的需要买书吗？ &emsp;&emsp;Android是开源的，本身就有很好的文档，如果看文档不过瘾，那直接看代码啊！学习这类东西，买书的话很不划算。写一本好的IT书籍需要花多长时间？一年？两年？五年？写出来之后还要校正排版印刷出版发行，等到你手里，书里的内容基本上也就过时了。几个月写出来的书能看吗？根据经验这类书都是翻译官方文档+复制原版示例代码而成。 &emsp;&emsp;记得以前大学的时候买过一本xxx开发指南，买过来看了两三天就丢抽屉里吃灰去了，完全没有看下去的欲望，现在已经不知道丢哪了。 &emsp;&emsp;所以，如果希望学习新技术，想破头在挑选买哪本书的朋友，先认真思考一下，真的有必要去买吗？特别是中文版。","categories":[{"name":"闲话","slug":"闲话","permalink":"http://excu4fun.com/categories/闲话/"}],"tags":[{"name":"闲话","slug":"闲话","permalink":"http://excu4fun.com/tags/闲话/"}]},{"title":"Time Or Money","slug":"time-or-money","date":"2018-10-21T16:00:00.000Z","updated":"2018-10-23T11:13:03.121Z","comments":true,"path":"2018/10/22/time-or-money/","link":"","permalink":"http://excu4fun.com/2018/10/22/time-or-money/","excerpt":"","text":"原作： J.D.Roth 翻译：翛凌 原文：Entrepreneur 关于作者J. D. Roth 《你的金钱：失落的使用手册》的作者。同时他也是个人金融博客 getrichslowly.org 的创立者和编辑。 &emsp;&emsp;「时间就是金钱，金钱就是时间」。这是 Joe Dominguez 和 Vicki Robin 合著的个人理财经典教程《你的金钱或你的时间》的中心思想。他们在书中写道，「金钱是我们选择通过耗费我们的能量这样一种方式来换取的东西。」 &emsp;&emsp;这两位作者的观点主要是这样的：你需要耗费时间才能获得金钱，因此你在买东西时花费的并不是你的金钱，而是你的时间。举例来说，假设你是一个一小时挣 50 美元的顾问，你买了一个价值 500 美元的 iPad。那么这个 iPad 实际上并不是花费了你 500 美元，而是耗费了你 10 小时的工作。如果你一小时只挣 25 美元，那么这个 iPad 实际上是时薪50美元的顾问的两倍，因为你需要工作 20 小时才能支付得起这个 iPad。 &emsp;&emsp;这种观点实际上有一些有力的实例。当你的花费变少的时候，你实际上可以工作得更少。节俭的人「买下」的时间比不节俭的人要多很多。 你的时间值多少钱？如果你是一个企业家，那么当你的生意越做越大的时候，你的时间也变得更为有价值。实际上你可以用一种非常简单的方式来计算你的时间的价值：假设你一周工作 h 小时，一年有 w 周。将你一整年的全部收入加起来，而后除以将你所有来源的收入加在一起，除以 ( h × w)，这就是你的时间所值的价钱。如果你需要做某件事情，计算一下究竟是你的时间更值钱还是请一个其他人做这个事情耗费的金钱更多。如果你的时间更值钱，那么就请人做这件事情。如果其他人的时间比较值钱，那么你还是自己来做这件事情吧。 &emsp;&emsp;实际上，有些精明的人已经发现了，极度节俭是一条能够让你实现提前退休的好方法。这再你的收入特别高的时尤为明显。如果你在二十多岁和三十多岁的时候能保证每月节省出至少一半甚至 70% 的工资时，你完全可以在 40 岁的时候退休，而不用像一般人一样 65 岁退休。 &emsp;&emsp;当然我们不可能每个人都适用这样的规律。但是从另一方面来说，金钱也可以买时间。Toni Anderson 又有一个叫做快乐主妇的网站。除了要管理这个逐渐扩大的网站，她还要照顾七个孩子。而她的丈夫，一名海军军官，却并不在她的身边，因此也无法帮助她照料事业和他们的七个孩子。Toni 也因此对时间和金钱之间的关系有着深刻的理解，所以在处理时间和金钱方面的平衡时非常有经验。 &emsp;&emsp;Toni 雇佣了以为助手去帮助她处理邮件并且帮助她整理生意上的一些细节（比如账单和募捐）。这样 Toni 就可以专注于处理她擅长的事情，也就是维持客户和消费者之间的关系。Toni 表示，「把你讨厌做的事情或者你不擅长做的事情委托给别人做就是其中的关键。」 &emsp;&emsp;像许多人一样，我花钱请了一个会计帮我管理我的税务问题。这不仅仅是因为他在这方面比我做得好、做得专业，而且还有个很重要的原因就是这只需要耗费他两个小时的时间。而如果要我自己处理这些问题，我可能需要 20 小时。同样，我还请了一个钟点工，每个月来我们家打扫两次房子。是的，请钟点工挺贵。不过这能让我花更多的时间去做那些我更擅长的、能拿到工资的工作。请钟点工能每个月让我多出几小时的空闲时间。而在这几小时内，我写了这篇文章。实际上，这篇文章的稿费够我请她在未来三个月内继续来我们家打扫卫生。 &emsp;&emsp;当然，在你刚开始一项事业的时候，比起金钱，你可能会拥有更多的时间。因此凡事亲力亲为、参与公司内的各项事务是非常合理的。但是一旦你的事业随着时间的推移逐渐做大，你的时间就会显得越来越少，而你的金钱则变得越来越多。此时花钱请一些员工去处理一些特定事情就变得非常有效。他们能帮助你分担一些你不擅长的工作，而你也能腾出更多时间处理你擅长的工作，获取更多的利润。 &emsp;&emsp;总结一下，在生活和工作上寻求平衡实际上就是平衡你使用金钱和使用时间的方式。如果买一个 iPad 只耗费你生命中 10 小时或者 20 小时的工作，那么买了 iPad 当然没有什么不可以。如果你需要工作更久的时间工作才能买得起这个 iPad ，那么请不要买这个 iPad 。就当帮自己一个忙：存下来这笔用来买 iPad 的钱。这样你以后就能早点退休，享受自己喜爱的生活了。","categories":[{"name":"文摘","slug":"文摘","permalink":"http://excu4fun.com/categories/文摘/"}],"tags":[{"name":"文摘","slug":"文摘","permalink":"http://excu4fun.com/tags/文摘/"}]},{"title":"Cocos2d-x3.10使用obb扩展包","slug":"android-obb","date":"2018-10-20T16:00:00.000Z","updated":"2018-10-22T07:06:27.466Z","comments":true,"path":"2018/10/21/android-obb/","link":"","permalink":"http://excu4fun.com/2018/10/21/android-obb/","excerpt":"","text":"一. 创建Obb文件并模拟下载环境1.1 Obb文件命名规则根据google官方的OBB文件命名规则来创建Obb文件：12&lt;main|patch&gt;.&lt;expansion-version&gt;.&lt;package-name&gt;.obb//例如：main.10001.com.demo.app.obb main|patch: main代表主扩展包，patch代表补充扩展包，一般只使用main关键字。expansion-version: 即version code。package-name: 包名。obb：后缀，本质为zip文件。 注意：上传google后台时，测试包的version code不能与正式包的version code相同，google不允许上传相同版本的app，即使其中一个是用来测试。 1.2 创建obb文件推荐使用winrar来创建obb文件，选择需要做成obb扩展包的资源文件，将其压缩，配置如下 注意：压缩文件格式选择”zip“，压缩方式选择”存储“ 1.3 本地模拟obb环境测试将创建好的obb文件放入手机sdcard/Android/obb/com.yourpackageName/目录下，如果本地没有相应目录，则手动创建即可（apk与obb上传google play后台之后，用户下载应用会自动创建相应目录）完成本地测试环境。 二. 修改引擎层代码Cocos2d-x3.16版本已添加读取obb文件功能，但3.16之前版本的则需要修改引擎部分代码才能读取obb文件 2.1 修改Java_org_cocos2dx_lib_Cocos2dxHelper.cpp在Java_org_cocos2dx_lib_Cocos2dxHelper.cpp中添加如下代码：1234567891011//添加obb pathstring g_obbPath//添加设置obbpath方法 JNIEXPORT void JNICALL Java_org_cocos2dx_lib_Cocos2dxHelper_nativeSetObbPath(JNIEnv* env, jobject thiz, jstring obbPath) &#123; g_obbPath = JniHelper::jstring2string(obbPath); &#125;//添加获取obbpath 方法const char * getObbPath()&#123; return g_obbPath.c_str();&#125; Java_org_cocos2dx_lib_Cocos2dxHelper.h中添加如下代码：12//添加方法extern const char * getObbPath(); 2.2 修改CCFileUtils-android.cpp在CCFileUtilsAndroid.h中添加：12#include \"base/ZipUtils.h\"//如要引入头文件，请确保Android.mk中配置了正确的路径 在CCFileUtilsAndroid.cpp中：12//创建全局指针变量obbFileZipFile *obbFile; 在构造函数FileUtilsAndroid::FileUtilsAndroid()中添加：1234FileUtilsAndroid::FileUtilsAndroid()&#123; obbFile = nullptr;&#125; 在析构函数FileUtilsAndroid::~FileUtilsAndroid()中添加：1234567FileUtilsAndroid::~FileUtilsAndroid()&#123; if(obbFile != nullptr) &#123; delete obbFile; obbFile = NULL; &#125;&#125; 有心的同学可以发现上述添加在之后的代码里中创建了一个单例模式 在isFileExistInternal()方法中做如下修改： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//引擎层代码不建议直接复制，建议与本地代码仔细比对后手动修改，注释部分用于方便看日志，可忽略bool FileUtilsAndroid::isFileExistInternal(const std::string&amp; strFilePath) const&#123; if (strFilePath.empty()) &#123; return false; &#125; bool bFound = false; // Check whether file exists in apk. if (strFilePath[0] != '/') &#123; const char* s = strFilePath.c_str(); // Found \"assets/\" at the beginning of the path and we dont want it if (strFilePath.find(_defaultResRootPath) == 0) s += strlen(\"assets/\"); if (FileUtilsAndroid::assetmanager) &#123; AAsset* aa = AAssetManager_open(FileUtilsAndroid::assetmanager, s, AASSET_MODE_UNKNOWN); if (aa) &#123; bFound = true; AAsset_close(aa); &#125;else&#123; if(getObbPath() != nullptr)&#123; // CCLOG(\"[AssetManager] ... in APK %s,%s, found = false! \\n obbPath=%s\", strFilePath.c_str(),s, getObbPath()); // ZipFile *obbFile = new ZipFile(getObbPath()); if (obbFile == nullptr) &#123; obbFile = new ZipFile(getObbPath()); &#125; if ( obbFile-&gt;fileExists(strFilePath.c_str()) ) &#123; // CCLOG(\"obb ... in APK %s, found = true!\", strFilePath.c_str()); bFound = true; // delete obbFile; // obbFile = NULL; &#125;else&#123; // CCLOG(\"obb ... in APK %s, found = false!\", strFilePath.c_str()); &#125; &#125; &#125; &#125; &#125; else &#123; FILE *fp = fopen(strFilePath.c_str(), \"r\"); if(fp) &#123; bFound = true; fclose(fp); &#125; &#125; return bFound;&#125; 在getData()方法中做如下修改： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123Data FileUtilsAndroid::getData(const std::string&amp; filename, bool forString)&#123; if (filename.empty()) &#123; return Data::Null; &#125; unsigned char* data = nullptr; ssize_t size = 0; string fullPath = fullPathForFilename(filename); if (fullPath[0] != '/') &#123; string relativePath = string(); size_t position = fullPath.find(\"assets/\"); if (0 == position) &#123; // \"assets/\" is at the beginning of the path and we dont want it relativePath += fullPath.substr(strlen(\"assets/\")); &#125; else &#123; relativePath += fullPath; &#125; LOGD(\"relative path = %s\", relativePath.c_str()); if (nullptr == FileUtilsAndroid::assetmanager) &#123; LOGD(\"... FileUtilsAndroid::assetmanager is nullptr\"); return Data::Null; &#125; // read asset data AAsset* asset = AAssetManager_open(FileUtilsAndroid::assetmanager, relativePath.c_str(), AASSET_MODE_UNKNOWN); if (nullptr != asset) &#123; off_t fileSize = AAsset_getLength(asset); if (forString) &#123; data = (unsigned char*) malloc(fileSize + 1); data[fileSize] = '\\0'; &#125; else &#123; data = (unsigned char*) malloc(fileSize); &#125; int bytesread = AAsset_read(asset, (void*)data, fileSize); size = bytesread; CCLOG(\"apk size test: size=%d;fileSize=%d\", size, fileSize); AAsset_close(asset); // return Data::Null; &#125;else&#123; CCLOG(\"asset is nullptr\"); ZipFile zipFile(getApkPath()); // CCLOG(\"guok special read: %s;forString=%d\", relativePath.c_str(), forString); string zFileNamePath = \"assets/\" + relativePath; // CCLOG(\"zFileNamePath =%s \",zFileNamePath.c_str()); // CCLOG(\"getObbPath() = %s\",getObbPath()); if ( zipFile.fileExists(zFileNamePath.c_str()) ) &#123; ssize_t fsize = 0 ; unsigned char* content = zipFile.getFileData(zFileNamePath.c_str(), &amp;fsize); // CCLOG(\"zipFile is exists!\"); if( fsize &gt; 0) &#123; // CCLOG(\"guok read success %d\", fsize); memcpy( data, content, fsize); size = fsize; &#125; else &#123; // CCLOG(\"guok read error %d\", fsize); &#125; if(content)free(content); &#125; else if(getObbPath() != nullptr)&#123; if (obbFile == nullptr) &#123; obbFile = new ZipFile(getObbPath()); &#125; // CCLOG(\"getObbPath() is exists!\"); string s = getObbPath(); string zObbNamePath = \"assets/\" + relativePath; // CCLOG(\"zObbNamePath = %s\",zObbNamePath.c_str()); if ( obbFile-&gt;fileExists(zObbNamePath.c_str()) ) &#123; ssize_t fsize = 0; unsigned char* content = obbFile-&gt;getFileData(zObbNamePath.c_str(), &amp;fsize); // CCLOG(\"obbFile is exists!\"); if( fsize &gt; 0) &#123; CCLOG(\"fsize = %d\",fsize); if (forString) &#123; data = (unsigned char*) malloc(fsize + 1); data[fsize] = '\\0'; // CCLOG(\"ssssssssssss\"); &#125;else&#123; data = (unsigned char*) malloc(fsize); // CCLOG(\"qqqqqqqqqqqqqqqqqqqq\"); &#125; memcpy( data, content, fsize); size = fsize; // CCLOG(\"obb getdata success %d\", fsize); &#125; else &#123; // CCLOG(\"obb getdata error %d\", fsize); &#125; if(content)free(content); &#125; &#125; if (size &lt;= 0) &#123; CCLOG(\"obb null size %d\", size); return Data::Null; &#125; &#125; &#125; else &#123; do &#123; ................... &#125; 在getFileData()方法中做如下修改： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114unsigned char* FileUtilsAndroid::getFileData(const std::string&amp; filename, const char* mode, ssize_t * size)&#123; unsigned char * data = 0; if ( filename.empty() || (! mode) ) &#123; return 0; &#125; string fullPath = fullPathForFilename(filename); if (fullPath[0] != '/') &#123; string relativePath = string(); size_t position = fullPath.find(\"assets/\"); if (0 == position) &#123; // \"assets/\" is at the beginning of the path and we dont want it relativePath += fullPath.substr(strlen(\"assets/\")); &#125; else &#123; relativePath += fullPath; &#125; LOGD(\"relative path = %s\", relativePath.c_str()); if (nullptr == FileUtilsAndroid::assetmanager) &#123; LOGD(\"... FileUtilsAndroid::assetmanager is nullptr\"); return nullptr; &#125; // read asset data AAsset* asset = AAssetManager_open(FileUtilsAndroid::assetmanager, relativePath.c_str(), AASSET_MODE_UNKNOWN); if (nullptr != asset) &#123; LOGD(\"asset is not nullptr\"); off_t fileSize = AAsset_getLength(asset); data = (unsigned char*) malloc(fileSize); int bytesread = AAsset_read(asset, (void*)data, fileSize); if (size) &#123; *size = bytesread; &#125; AAsset_close(asset); &#125; else &#123; LOGD(\"asset is nullptr\"); ZipFile zipFile(getApkPath()); CCLOG(\" special read: %s\", relativePath.c_str()); string zFileNamePath = \"assets/\" + relativePath; if ( zipFile.fileExists(zFileNamePath.c_str()) ) &#123; ssize_t fsize = 0; unsigned char* content = zipFile.getFileData(zFileNamePath.c_str(), &amp;fsize); if( fsize &gt; 0) &#123; // CCLOG(\"getfiledata success %d\", fsize); data = (unsigned char*) malloc(fsize); memcpy( data, content, fsize); if (size) &#123; *size = fsize; &#125; &#125; else &#123; CCLOG(\"getfiledata error %d\", fsize); &#125; if(content)free(content); &#125; else if(getObbPath() != nullptr)&#123; if (obbFile == nullptr) &#123; obbFile = new ZipFile(getObbPath()); &#125; string zObbNamePath = \"assets/\" + relativePath; // CCLOG(\"zObbNamePath = %s\",zObbNamePath.c_str()); if ( obbFile-&gt;fileExists(zObbNamePath.c_str()) ) &#123; ssize_t fsize = 0; unsigned char* content = obbFile-&gt;getFileData(zObbNamePath.c_str(), &amp;fsize); delete obbFile; obbFile = NULL; if( fsize &gt; 0) &#123; // CCLOG(\"obb getfiledata success %d\", fsize); data = (unsigned char*) malloc(fsize); memcpy( data, content, fsize); if (size) &#123; *size = fsize; &#125; &#125; else &#123; // CCLOG(\"obb getfiledata error %d\", fsize); &#125; if(content)free(content); &#125; &#125; &#125; if (!data) &#123; CCLOG(\"getFileData error: %s\", relativePath.c_str()); return nullptr; &#125; &#125; else &#123; do &#123; ................... &#125; 三. 修改安卓层代码准备工作：在Android Studio工程中导入google官方提供的库google_market_apk_expansion,具体可查看Android官方文档，所需的库可通过Android SDK Manager进行下载 3.1 在AndroidManifest.xml中配置相关权限123456&lt;uses-permission android:name=\"com.android.vending.CHECK_LICENSE\" /&gt;&lt;uses-permission android:name=\"android.permission.INTERNET\" /&gt;&lt;uses-permission android:name=\"android.permission.WAKE_LOCK\" /&gt;&lt;uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" /&gt;&lt;uses-permission android:name=\"android.permission.ACCESS_WIFI_STATE\"/&gt;&lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" / 3.2 在Cocos2dxActivity中添加变量及方法 123456789101112131415161718192021222324252627282930313233public static String FATE_OBB_PATH = \"\";public static String FATE_OBB_Name = \"\";@Override protected void onCreate(final Bundle savedInstanceState) &#123; FATE_OBB_Name = getObbFileName(); FATE_OBB_PATH = getVirtualObbFileFullpath(); super.onCreate(savedInstanceState); .... &#125; private String getObbFileName() &#123; PackageInfo info = null; try &#123; info = getPackageManager().getPackageInfo(getPackageName(), 0); String fileName = \"main.\" + info.versionCode + \".\" + getPackageName() + \".obb\"; Log.e(\"obb===fileName===\", fileName); return fileName; &#125; catch (NameNotFoundException e) &#123; e.printStackTrace(); &#125; return \"\"; &#125;private String getVirtualObbFileFullpath()&#123; String _path = \"\"; File file = getObbDir(); if(file == null || !file.exists())&#123; file.mkdirs(); &#125; _path = file.getPath() + \"/\" + getObbFileName(); Log.e(\"obb===_path===\", _path); return _path; &#125; 3.3 在Cocos2dxHelper中添加变量及方法 123public static ZipResourceFile obbzip = null;//使用需要外部依赖private static native void nativeSetObbPath(final String pObbPath);// nativeSetObbPath 设置obb路径方法 在init()中添加：12345678910111213141516171819202122232425262728293031323334353637383940public static void init(final Activity activity) &#123; if (!sInited) &#123; final ApplicationInfo applicationInfo = activity.getApplicationInfo(); Cocos2dxHelper.sCocos2dxHelperListener = (Cocos2dxHelperListener)activity; Cocos2dxHelper.sPackageName = applicationInfo.packageName; Cocos2dxHelper.sFileDirectory = activity.getFilesDir().getAbsolutePath(); Cocos2dxHelper.nativeSetApkPath(applicationInfo.sourceDir); Cocos2dxHelper.sCocos2dxAccelerometer = new Cocos2dxAccelerometer(activity); Cocos2dxHelper.sCocos2dMusic = new Cocos2dxMusic(activity); Cocos2dxHelper.sCocos2dSound = new Cocos2dxSound(activity); Cocos2dxHelper.sAssetManager = activity.getAssets(); if (fileIsExists(Cocos2dxActivity.FATE_OBB_PATH)) &#123; Cocos2dxHelper.nativeSetObbPath(Cocos2dxActivity.FATE_OBB_PATH); &#125; PackageInfo info = null; try &#123; info = activity.getPackageManager().getPackageInfo( activity.getPackageName(), 0); Cocos2dxHelper.obbzip = APKExpansionSupport .getAPKExpansionZipFile(activity, info.versionCode, 0); &#125; catch (PackageManager.NameNotFoundException e1) &#123; e1.printStackTrace(); &#125; catch (IOException e1) &#123; e1.printStackTrace(); &#125; Cocos2dxHelper.nativeSetContext((Context)activity, Cocos2dxHelper.sAssetManager); Cocos2dxBitmap.setContext(activity); Cocos2dxETCLoader.setContext(activity); sActivity = activity; sInited = true; &#125; &#125; 添加fileIsExists方法：123456789101112131415public static boolean fileIsExists(String strFile) &#123; if(strFile.isEmpty())&#123; return false; &#125; try &#123; File f = new File(strFile); if (!f.exists()) &#123; return false; &#125; &#125; catch (Exception e) &#123; return false; &#125; Log.d(\"obb\", \"file exist!\"); return true;&#125; 3.4 修改Cocos2dxMusic将1mediaPlayer.setDataSource(assetFileDescritor.getFileDescriptor(),assetFileDescritor.getStartOffset(), assetFileDescritor.getLength()); 替换为：12345678final AssetFileDescriptor assetFileDescritor = Cocos2dxHelper.obbzip.getAssetFileDescriptor(\"assets/\"+pPath); if(assetFileDescritor == null)&#123; final AssetFileDescriptor assetFileDescritor1 = this.mContext.getAssets().openFd(pPath); mediaPlayer.setDataSource(assetFileDescritor1.getFileDescriptor(), assetFileDescritor1.getStartOffset(), assetFileDescritor1.getLength()); &#125;else&#123; mediaPlayer.setDataSource(assetFileDescritor.getFileDescriptor(), assetFileDescritor.getStartOffset(), assetFileDescritor.getLength()); &#125; 3.5 修改Cocos2dxSound将1soundID = this.mSoundPool.load(this.mContext.getAssets().openFd(pPath), 0); 替换为：12345678910final AssetFileDescriptor assetFileDescritor = Cocos2dxHelper.obbzip .getAssetFileDescriptor(\"assets/\" + pPath); if (assetFileDescritor == null) &#123; final AssetFileDescriptor assetFileDescritor1 = this.mContext .getAssets().openFd(pPath); soundID = this.mSoundPool.load(assetFileDescritor1, 0); &#125; else &#123; soundID = this.mSoundPool.load(assetFileDescritor, 0); &#125; 3.6 在主Activity中添加代码12345678910111213141516171819private static final int REQUEST_EXTERNAL_STORAGE = 1;private static String[] PERMISSIONS_STORAGE = &#123; \"android.permission.READ_EXTERNAL_STORAGE\", \"android.permission.WRITE_EXTERNAL_STORAGE\" &#125;;public static void verifyStoragePermissions(Sprites activity) &#123; try &#123; //检测是否有写的权限 int permission = ActivityCompat.checkSelfPermission(activity, \"android.permission.WRITE_EXTERNAL_STORAGE\"); if (permission != PackageManager.PERMISSION_GRANTED) &#123; // 没有写的权限，去申请写的权限，弹出对话框 ActivityCompat.requestPermissions(activity, PERMISSIONS_STORAGE,REQUEST_EXTERNAL_STORAGE); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 在onCreate()中添加：12345678910111213141516171819202122232425262728293031323334//判断是否有sd卡读写权限，如果没有，则去申请！verifyStoragePermissions(Sprites.this); //检测是否已经下载到了obb包,如果没有，则弹出错误提示，killProcessif (Cocos2dxActivity.FATE_OBB_PATH.isEmpty() || !Cocos2dxHelper.fileIsExists(Cocos2dxActivity.FATE_OBB_PATH)) &#123; // 创建构建器 AlertDialog.Builder builder = new AlertDialog.Builder(this); // 设置参数 builder.setTitle(\"提示\").setIcon(R.drawable.icon) .setMessage(\"游戏资源已损坏，请重新下载！\") .setPositiveButton(\"退出\", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; // TODO Auto-generated method stub android.os.Process.killProcess(android.os.Process.myPid()); &#125; &#125;); builder.create().show(); new Handler().postDelayed(new Runnable()&#123; //延时3s退出程序 public void run() &#123; android.os.Process.killProcess(android.os.Process.myPid()); //execute the task &#125; &#125;, 3000); //如果未检测到obb包，延时3s后关闭程序&#125;/*这里最正确的方法应该是如果未检测到obb包，则去google后台手动下载，但这一部分的内容非常多而繁琐，在本篇中不进行详述，google官方表示不保证所有机型都可以下载得到obb包，因此需要添加手动下载的功能，通过公司的游戏实际检验，下载不到obb包的概率小于1%（当然这个统计不是很专业，也有可能有玩家没下载到obb包但没有反馈）如要添加此功能，需要依赖google配套的库，但是关于download方面的库年代已经很久远了，许多方法现在已经废弃，而google又一直没有升级过这个库，导致想要用需要自己手动去修改里面的n多错误，这将是件令人很头疼的问题，如果有时间，我会在之后的blog中记录如何实现这一过程*/ 总结完成以上修改之后，就可以先将obb包copy到手机相关目录下进行本地测试，没有问题就可以上传google beta测试包到googleplay后台去进行相关测试了，这部分内容是大学毕业进入公司后接手的第一个项目，全部完成用了一周的时间，之前公司一直是使用热更的方法来应对google的100Mapk上传限制，导致玩家每次都要下载一个很大的更新包，影响游戏体验，因此公司决定使用obb分包的方式上传apk，在此还要感谢老陈对我这个刚来的菜鸟的信任，将这份任务交给我，此致。","categories":[{"name":"Android","slug":"Android","permalink":"http://excu4fun.com/categories/Android/"}],"tags":[{"name":"Cocos2d-x","slug":"Cocos2d-x","permalink":"http://excu4fun.com/tags/Cocos2d-x/"},{"name":"Android","slug":"Android","permalink":"http://excu4fun.com/tags/Android/"}]}]}